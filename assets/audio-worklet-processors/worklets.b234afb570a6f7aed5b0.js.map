{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/audio-worklet-processors/getParameterValue.js","webpack:///./src/audio-worklet-processors/clamp.js","webpack:///./src/audio-worklet-processors/noise.js","webpack:///./src/audio-worklet-processors/inverse-gain.js","webpack:///./src/audio-worklet-processors/getEnvelopeValue.js","webpack:///./src/audio-worklet-processors/linear-change.js","webpack:///./src/audio-worklet-processors/envelope-generator.js","webpack:///./src/audio-worklet-processors/crush-bit-fixed-point.js","webpack:///./src/audio-worklet-processors/bit-crusher-fixed-point.js","webpack:///./src/audio-worklet-processors/divide-clock-ticks.js","webpack:///./src/audio-worklet-processors/clock-divider.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","getParameterValue","parameter","minValue","maxValue","sampleNumber","clampValue","input","clamp","length","_getParameterValue__WEBPACK_IMPORTED_MODULE_0__","getNextValue","previousValue","stepMin","stepMax","stepSize","Math","random","registerProcessor","AudioWorkletProcessor","parameterDescriptors","defaultValue","automationRate","[object Object]","super","this","samplesHeld","isTriggerValueHigh","port","onmessage","handleMessage","manualTriggerOn","event","data","type","inputs","outputs","parameters","output","getStepMin","getStepMax","getSampleHold","sampleHold","getNextValueTrigger","nextValueTrigger","triggerValue","postMessage","channel","divisor","getDivisor","getZeroDivisorOutput","zeroDivisorFallback","channelIndex","inputChannel","outputChannel","sampleIndex","inputSample","getEnvelopeValue","getValueAtTime","sampleRate","attackTime","attackValue","holdTime","decayTime","sustainValue","releaseTime","secondsSinceStateTransition","stage","valueOnTriggerChange","sampleTime","stageOutput","secondsSinceStateTransitionOutput","stageProgressOutput","valueOnTriggerChangeOutput","undefined","valueOutput","stageProgress","outputValue","startValue","startTime","endValue","endTime","currentTime","options","stages","state","previousTriggerValue","getTriggerValue","trigger","getAttackTime","getAttackValue","getHoldTime","getDecayTime","getSustainValue","getReleaseTime","envelopeValue","crush","sample","bitDepth","fractionalDepthMode","floor","numberOfSteps","max","fractionalBitDepthMode","newMode","getBitDepth","clockInTriggerStages","attack","high","release","low","clockStages","tick","tock","resetTriggerStages","reset","keepGoing","divideClockTicks","attackAfterTicks","releaseAfterTocks","clockInStage","resetTriggerStage","tocksPast","ticksPast","userParams","initialReset","manualClockTriggerOn","manualResetTriggerOn","clockTriggerOn","resetTriggerOn","getClockTriggerValue","clockTrigger","getResetTriggerValue","resetTrigger","getAttackAfterTicks","getReleaseAfterTocks","clockTriggerValue","resetTriggerValue","clockTriggerStage"],"mappings":"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","file":"worklets.b234afb570a6f7aed5b0.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"./assets/audio-worklet-processors\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","import { clamp } from \"./clamp\";\n\nexport const getParameterValue = (parameter, minValue, maxValue) => sampleNumber => {\n  const clampValue = clamp(minValue, maxValue);\n  if (parameter.length > 1) {\n    return clampValue(parameter[sampleNumber]);\n  }\n  return clampValue(parameter[0]);\n};\n","export const clamp = (minValue, maxValue) => input =>\n  input < minValue ? minValue : input > maxValue ? maxValue : input;\n","import { getParameterValue } from './getParameterValue';\n\nconst getNextValue = (previousValue, stepMin, stepMax) => {\n  const stepSize = Math.random() * (stepMax - stepMin) + stepMin;\n  const preferUp = Math.random() > 0.5;\n  if (preferUp) {\n    return previousValue + stepSize > 1 ? previousValue - stepSize : previousValue + stepSize;\n  } else {\n    return previousValue - stepSize < -1 ? previousValue + stepSize : previousValue - stepSize;\n  }\n};\n\nregisterProcessor(\n  'noise',\n  class Noise extends AudioWorkletProcessor {\n    static get parameterDescriptors() {\n      return [\n        {\n          name: 'stepMax',\n          defaultValue: 1,\n          minValue: 0,\n          maxValue: 1,\n          automationRate: 'a-rate'\n        },\n        {\n          name: 'stepMin',\n          defaultValue: 0,\n          minValue: 0,\n          maxValue: 1,\n          automationRate: 'a-rate'\n        },\n        {\n          name: 'sampleHold',\n          defaultValue: 1,\n          minValue: 0,\n          maxValue: 1000000,\n          automationRate: 'a-rate'\n        },\n        {\n          name: 'nextValueTrigger',\n          defaultValue: 0,\n          automationRate: 'a-rate'\n        }\n      ];\n    }\n\n    constructor() {\n      super();\n      // initializing to zero means max and min of 1 behaves differently on initial load\n      // start unbalanced so there is only one option for next sample in that case\n      this.previousValue = 0.1;\n      this.samplesHeld = 0;\n      this.isTriggerValueHigh = false;\n      this.port.onmessage = this.handleMessage.bind(this);\n      this.manualTriggerOn = false;\n    }\n\n    handleMessage(event) {\n      if (event.data && event.data.type === 'manual-trigger') {\n        this.manualTriggerOn = event.data.value;\n      }\n    }\n\n    process(inputs, outputs, parameters) {\n      // Get the first output.\n      let output = outputs[0];\n      let getStepMin = getParameterValue(parameters.stepMin, 0, 1);\n      let getStepMax = getParameterValue(parameters.stepMax, 0, 1);\n      let getSampleHold = getParameterValue(parameters.sampleHold, 0, 1000000);\n\n      let getNextValueTrigger = this.manualTriggerOn\n        ? () => 1e9\n        : getParameterValue(parameters.nextValueTrigger, 0, 1);\n\n      for (let i = 0; i < output[0].length; ++i, ++this.samplesHeld) {\n        // recover from overflow\n        if (this.samplesHeld < 0) {\n          this.samplesHeld = 0;\n        }\n\n        const sampleHold = getSampleHold(i);\n\n        // keep playing previous sample forever if sampleHold < 1\n        if (sampleHold >= 1 && this.samplesHeld >= sampleHold) {\n          this.samplesHeld -= sampleHold;\n          this.previousValue = getNextValue(this.previousValue, getStepMin(i), getStepMax(i));\n        }\n        const triggerValue = getNextValueTrigger(i);\n        if (this.isTriggerValueHigh != triggerValue > 0) {\n          this.port.postMessage({ type: 'trigger-change', value: triggerValue > 0 });\n        }\n        if (!this.isTriggerValueHigh && triggerValue > 0) {\n          this.previousValue = getNextValue(this.previousValue, getStepMin(i), getStepMax(i));\n        }\n        this.isTriggerValueHigh = triggerValue > 0;\n        for (let channel = 0; channel < output.length; ++channel) {\n          output[channel][i] = this.previousValue;\n        }\n      }\n      return true;\n    }\n  }\n);\n","registerProcessor(\n  'inverse-gain',\n  class Noise extends AudioWorkletProcessor {\n    static get parameterDescriptors() {\n      return [\n        {\n          name: 'divisor',\n          defaultValue: 10,\n          automationRate: 'a-rate'\n        },\n        {\n          name: 'zeroDivisorFallback',\n          defaultValue: 0,\n          automationRate: 'a-rate'\n        }\n      ];\n    }\n\n    process(inputs, outputs, parameters) {\n      // Only one input and output.\n      let input = inputs[0];\n      let output = outputs[0];\n      let divisor = parameters.divisor;\n      let divisorLength = divisor.length;\n      let getDivisor = divisorLength > 1 ? i => divisor[i] : () => divisor[0];\n      let getZeroDivisorOutput =\n        parameters.zeroDivisorFallback.length > 1\n          ? i => parameters.zeroDivisorFallback[i]\n          : () => parameters.zeroDivisorFallback[0];\n\n      for (let channelIndex = 0; channelIndex < input.length; channelIndex++) {\n        const inputChannel = input[channelIndex];\n        const outputChannel = output[channelIndex];\n        for (\n          let sampleIndex = 0;\n          sampleIndex < inputChannel.length;\n          sampleIndex++\n        ) {\n          const inputSample = inputChannel[sampleIndex];\n          const divisor = getDivisor(sampleIndex);\n          if (divisor === 0) {\n            outputChannel[sampleIndex] = getZeroDivisorOutput(sampleIndex);\n          } else {\n            outputChannel[sampleIndex] = inputSample / divisor;\n          }\n        }\n      }\n      return true;\n    }\n  }\n);\n","// ASSUMPTION: this will be called every sample, so it's safe to always advance time by one sample\n// returns the value at end of the sample, so if attack time is 0, attack value will be returned on the sample of the recieved trigger\nexport const getEnvelopeValue = (\n  getValueAtTime,\n  sampleRate,\n  { attackTime, attackValue, holdTime, decayTime, sustainValue, releaseTime },\n  secondsSinceStateTransition,\n  stage,\n  triggerValue,\n  valueOnTriggerChange\n) => {\n  const sampleTime = 1 / sampleRate;\n  let stageOutput;\n  let secondsSinceStateTransitionOutput;\n  let stageProgressOutput = 0;\n  let valueOnTriggerChangeOutput = undefined;\n  let valueOutput = undefined;\n  if (stage === 'rest') {\n    if (triggerValue <= 0) {\n      stageOutput = 'rest';\n      secondsSinceStateTransitionOutput = secondsSinceStateTransition + sampleTime;\n      valueOutput = 0;\n    } else {\n      if (sampleTime < attackTime) {\n        stageOutput = 'attack';\n        secondsSinceStateTransitionOutput = sampleTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / attackTime;\n        valueOnTriggerChangeOutput = 0;\n        valueOutput = getValueAtTime(\n          0,\n          0,\n          attackValue,\n          attackTime,\n          secondsSinceStateTransitionOutput\n        );\n      } else if (sampleTime - attackTime < holdTime) {\n        stageOutput = 'hold';\n        secondsSinceStateTransitionOutput = sampleTime - attackTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / holdTime;\n        valueOutput = attackValue;\n      } else if (sampleTime - attackTime - holdTime < decayTime) {\n        stageOutput = 'decay';\n        secondsSinceStateTransitionOutput = sampleTime - attackTime - holdTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / decayTime;\n        valueOutput = getValueAtTime(\n          attackValue,\n          0,\n          sustainValue,\n          decayTime,\n          secondsSinceStateTransitionOutput\n        );\n      } else {\n        stageOutput = 'sustain';\n        secondsSinceStateTransitionOutput = sampleTime - attackTime - holdTime - decayTime;\n        valueOutput = sustainValue;\n      }\n    }\n  }\n  if (stage === 'attack') {\n    if (triggerValue <= 0) {\n      if (sampleTime < releaseTime) {\n        stageOutput = 'release';\n        secondsSinceStateTransitionOutput = sampleTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / releaseTime;\n        if (secondsSinceStateTransition < attackTime) {\n          valueOnTriggerChangeOutput = getValueAtTime(\n            valueOnTriggerChange || 0,\n            0,\n            attackValue,\n            attackTime,\n            secondsSinceStateTransition\n          );\n        } else if (secondsSinceStateTransition - attackTime < holdTime) {\n          valueOnTriggerChangeOutput = attackValue;\n        } else if (secondsSinceStateTransition - attackTime - holdTime < decayTime) {\n          valueOnTriggerChangeOutput = getValueAtTime(\n            attackValue,\n            0,\n            sustainValue,\n            decayTime,\n            secondsSinceStateTransition - attackTime - holdTime\n          );\n        } else {\n          valueOnTriggerChangeOutput = sustainValue;\n        }\n        valueOutput = getValueAtTime(\n          valueOnTriggerChangeOutput,\n          0,\n          0,\n          releaseTime,\n          secondsSinceStateTransitionOutput\n        );\n      } else {\n        stageOutput = 'rest';\n        secondsSinceStateTransitionOutput = sampleTime - releaseTime;\n        valueOutput = 0;\n      }\n    } else {\n      if (secondsSinceStateTransition + sampleTime < attackTime) {\n        stageOutput = 'attack';\n        secondsSinceStateTransitionOutput = secondsSinceStateTransition + sampleTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / attackTime;\n        valueOnTriggerChangeOutput = valueOnTriggerChange;\n        valueOutput = getValueAtTime(\n          valueOnTriggerChange || 0,\n          0,\n          attackValue,\n          attackTime,\n          secondsSinceStateTransitionOutput\n        );\n      } else if (secondsSinceStateTransition + sampleTime - attackTime < holdTime) {\n        stageOutput = 'hold';\n        secondsSinceStateTransitionOutput = secondsSinceStateTransition + sampleTime - attackTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / holdTime;\n        valueOutput = attackValue;\n      } else if (secondsSinceStateTransition + sampleTime - attackTime - holdTime < decayTime) {\n        stageOutput = 'decay';\n        secondsSinceStateTransitionOutput =\n          secondsSinceStateTransition + sampleTime - attackTime - holdTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / decayTime;\n        valueOutput = getValueAtTime(\n          attackValue,\n          0,\n          sustainValue,\n          decayTime,\n          secondsSinceStateTransitionOutput\n        );\n      } else {\n        stageOutput = 'sustain';\n        secondsSinceStateTransitionOutput =\n          secondsSinceStateTransition + sampleTime - attackTime - holdTime - decayTime;\n        valueOutput = sustainValue;\n      }\n    }\n  }\n  if (stage === 'hold') {\n    if (triggerValue <= 0) {\n      if (sampleTime < releaseTime) {\n        stageOutput = 'release';\n        secondsSinceStateTransitionOutput = sampleTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / releaseTime;\n        if (secondsSinceStateTransition < holdTime) {\n          valueOnTriggerChangeOutput = attackValue;\n        } else if (secondsSinceStateTransition - holdTime < decayTime) {\n          valueOnTriggerChangeOutput = getValueAtTime(\n            attackValue,\n            0,\n            sustainValue,\n            decayTime,\n            secondsSinceStateTransition - holdTime\n          );\n        } else {\n          valueOnTriggerChangeOutput = sustainValue;\n        }\n        valueOutput = getValueAtTime(\n          valueOnTriggerChangeOutput,\n          0,\n          0,\n          releaseTime,\n          secondsSinceStateTransitionOutput\n        );\n      } else {\n        stageOutput = 'rest';\n        secondsSinceStateTransitionOutput = sampleTime - releaseTime;\n        valueOutput = 0;\n      }\n    } else {\n      if (secondsSinceStateTransition + sampleTime < holdTime) {\n        stageOutput = 'hold';\n        secondsSinceStateTransitionOutput = secondsSinceStateTransition + sampleTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / holdTime;\n        valueOutput = attackValue;\n      } else if (secondsSinceStateTransition + sampleTime - holdTime < decayTime) {\n        stageOutput = 'decay';\n        secondsSinceStateTransitionOutput = secondsSinceStateTransition + sampleTime - holdTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / decayTime;\n        valueOutput = getValueAtTime(\n          attackValue,\n          0,\n          sustainValue,\n          decayTime,\n          secondsSinceStateTransitionOutput\n        );\n      } else {\n        stageOutput = 'sustain';\n        secondsSinceStateTransitionOutput =\n          secondsSinceStateTransition + sampleTime - holdTime - decayTime;\n        valueOutput = sustainValue;\n      }\n    }\n  }\n  if (stage === 'decay') {\n    if (triggerValue <= 0) {\n      if (sampleTime < releaseTime) {\n        stageOutput = 'release';\n        secondsSinceStateTransitionOutput = sampleTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / releaseTime;\n        if (secondsSinceStateTransition < decayTime) {\n          valueOnTriggerChangeOutput = getValueAtTime(\n            attackValue,\n            0,\n            sustainValue,\n            decayTime,\n            secondsSinceStateTransition\n          );\n        } else {\n          valueOnTriggerChangeOutput = sustainValue;\n        }\n        valueOutput = getValueAtTime(\n          valueOnTriggerChangeOutput,\n          0,\n          0,\n          releaseTime,\n          secondsSinceStateTransitionOutput\n        );\n      } else {\n        stageOutput = 'rest';\n        secondsSinceStateTransitionOutput = sampleTime - releaseTime;\n        valueOutput = 0;\n      }\n    } else {\n      if (secondsSinceStateTransition + sampleTime < decayTime) {\n        stageOutput = 'decay';\n        secondsSinceStateTransitionOutput = secondsSinceStateTransition + sampleTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / decayTime;\n        valueOutput = getValueAtTime(\n          attackValue,\n          0,\n          sustainValue,\n          decayTime,\n          secondsSinceStateTransitionOutput\n        );\n      } else {\n        stageOutput = 'sustain';\n        secondsSinceStateTransitionOutput = secondsSinceStateTransition + sampleTime - decayTime;\n        valueOutput = sustainValue;\n      }\n    }\n  }\n  if (stage === 'sustain') {\n    if (triggerValue <= 0) {\n      if (sampleTime < releaseTime) {\n        stageOutput = 'release';\n        secondsSinceStateTransitionOutput = sampleTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / releaseTime;\n        valueOnTriggerChangeOutput = sustainValue;\n        valueOutput = getValueAtTime(\n          valueOnTriggerChangeOutput,\n          0,\n          0,\n          releaseTime,\n          secondsSinceStateTransitionOutput\n        );\n      } else {\n        stageOutput = 'rest';\n        secondsSinceStateTransitionOutput = sampleTime - releaseTime;\n        valueOutput = 0;\n      }\n    } else {\n      stageOutput = 'sustain';\n      secondsSinceStateTransitionOutput = secondsSinceStateTransition + sampleTime;\n      valueOutput = sustainValue;\n    }\n  }\n  if (stage === 'release') {\n    if (triggerValue <= 0) {\n      if (secondsSinceStateTransition + sampleTime < releaseTime) {\n        stageOutput = 'release';\n        secondsSinceStateTransitionOutput = secondsSinceStateTransition + sampleTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / releaseTime;\n        valueOnTriggerChangeOutput = valueOnTriggerChange;\n        valueOutput = getValueAtTime(\n          valueOnTriggerChangeOutput,\n          0,\n          0,\n          releaseTime,\n          secondsSinceStateTransitionOutput\n        );\n      } else {\n        stageOutput = 'rest';\n        secondsSinceStateTransitionOutput = secondsSinceStateTransition + sampleTime - releaseTime;\n        valueOutput = 0;\n      }\n    } else {\n      if (sampleTime < attackTime) {\n        stageOutput = 'attack';\n        secondsSinceStateTransitionOutput = sampleTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / attackTime;\n        valueOnTriggerChangeOutput = getValueAtTime(valueOnTriggerChange || 0, 0, 0, releaseTime, secondsSinceStateTransition);\n        valueOutput = getValueAtTime(\n          valueOnTriggerChangeOutput,\n          0,\n          attackValue,\n          attackTime,\n          secondsSinceStateTransitionOutput\n        );\n      } else if (sampleTime - attackTime < holdTime) {\n        stageOutput = 'hold';\n        secondsSinceStateTransitionOutput = sampleTime - attackTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / holdTime;\n        valueOutput = attackValue;\n      } else if (sampleTime - attackTime - holdTime < decayTime) {\n        stageOutput = 'decay';\n        secondsSinceStateTransitionOutput = sampleTime - attackTime - holdTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / decayTime;\n        valueOutput = getValueAtTime(\n          attackValue,\n          0,\n          sustainValue,\n          decayTime,\n          secondsSinceStateTransitionOutput\n        );\n      } else {\n        stageOutput = 'sustain';\n        secondsSinceStateTransitionOutput = sampleTime - attackTime - holdTime - decayTime;\n        valueOutput = sustainValue;\n      }\n    }\n  }\n  return {\n    stage: stageOutput,\n    stageProgress: stageProgressOutput,\n    secondsSinceStateTransition: secondsSinceStateTransitionOutput,\n    valueOnTriggerChange: valueOnTriggerChangeOutput,\n    outputValue: valueOutput\n  };\n};\n","export function getValueAtTime(\n  startValue,\n  startTime,\n  endValue,\n  endTime,\n  currentTime\n) {\n  if (startTime >= endTime) {\n    startTime = endTime;\n  }\n  if (currentTime >= endTime) {\n    return endValue;\n  }\n  if (currentTime <= startTime) {\n    return startValue;\n  }\n\n  const gradient = (endValue - startValue) / (endTime - startTime);\n  return startValue + (currentTime - startTime) * gradient;\n}\n","import { getParameterValue } from './getParameterValue';\nimport { getEnvelopeValue } from './getEnvelopeValue';\nimport { getValueAtTime } from './linear-change';\n\nregisterProcessor(\n  'envelope-generator',\n  class EnvelopeGenerator extends AudioWorkletProcessor {\n    static get parameterDescriptors() {\n      return [\n        {\n          name: 'trigger',\n          defaultValue: 0,\n          automationRate: 'a-rate'\n        },\n        {\n          name: 'attackValue',\n          defaultValue: 1,\n          minValue: 0,\n          maxValue: 1,\n          automationRate: 'a-rate'\n        },\n        {\n          name: 'attackTime',\n          defaultValue: 0.001,\n          minValue: 0,\n          maxValue: 10,\n          automationRate: 'a-rate'\n        },\n        {\n          name: 'holdTime',\n          minValue: 0,\n          defaultValue: 0.0625,\n          maxValue: 10,\n          automationRate: 'a-rate'\n        },\n        {\n          name: 'decayTime',\n          defaultValue: 0.125,\n          minValue: 0,\n          maxValue: 10,\n          automationRate: 'a-rate'\n        },\n        {\n          name: 'sustainValue',\n          defaultValue: 0.25,\n          minValue: 0,\n          maxValue: 1,\n          automationRate: 'a-rate'\n        },\n        {\n          name: 'releaseTime',\n          defaultValue: 0.25,\n          minValue: 0,\n          maxValue: 10\n        }\n      ];\n    }\n\n    constructor(options) {\n      super(options);\n      this.stages = ['rest', 'attack', 'hold', 'decay', 'sustain', 'release'];\n      this.stage = this.stages[0];\n      // stageProgress advances from 0 to 1 to show progress of stage\n      this.stageProgress = 0;\n      this.secondsSinceStateTransition = 0;\n      this.port.onmessage = this.handleMessage.bind(this);\n      this.state = {\n        attackTime: 0.001,\n        attackValue: 1,\n        holdTime: 0.0625,\n        decayTime: 0.125,\n        sustainValue: 0.25,\n        releaseTime: 0.25\n      };\n      this.sampleRate = options.sampleRate || 44100;\n      this.outputValue;\n      this.valueOnTriggerChange = undefined;\n      this.manualTriggerOn = false;\n      this.previousTriggerValue = 0;\n    }\n\n    handleMessage(event) {\n      if (event.data && event.data.type === 'getState') {\n        this.port.postMessage({\n          type: 'state',\n          state: {\n            stage: this.stage,\n            stageProgress: this.stageProgress,\n            outputValue: this.outputValue\n          }\n        });\n      }\n      if (event.data && event.data.type === 'manual-trigger') {\n        this.manualTriggerOn = event.data.value;\n      }\n    }\n\n    process(inputs, outputs, parameters) {\n      // Only one output.\n      let output = outputs[0];\n      const getTriggerValue = this.manualTriggerOn\n        ? () => 1e9\n        : getParameterValue(parameters.trigger, -1e9, 1e9);\n      const getAttackTime = getParameterValue(parameters.attackTime, 0, 10);\n      const getAttackValue = getParameterValue(parameters.attackValue, 0, 1);\n      const getHoldTime = getParameterValue(parameters.holdTime, 0, 10);\n      const getDecayTime = getParameterValue(parameters.decayTime, 0, 10);\n      const getSustainValue = getParameterValue(parameters.sustainValue, 0, 1);\n      const getReleaseTime = getParameterValue(parameters.releaseTime, 0, 10);\n\n      for (let sampleIndex = 0; sampleIndex < output[0].length; sampleIndex++) {\n        this.state.attackTime = getAttackTime(sampleIndex);\n        this.state.attackValue = getAttackValue(sampleIndex);\n        this.state.holdTime = getHoldTime(sampleIndex);\n        this.state.decayTime = getDecayTime(sampleIndex);\n        this.state.sustainValue = getSustainValue(sampleIndex);\n        this.state.releaseTime = getReleaseTime(sampleIndex);\n        const triggerValue = getTriggerValue(sampleIndex);\n\n        if (triggerValue > 0 != this.previousTriggerValue > 0) {\n          this.port.postMessage({ type: 'trigger-change', value: triggerValue > 0 });\n        }\n\n        const envelopeValue = getEnvelopeValue(\n          getValueAtTime,\n          this.sampleRate,\n          this.state,\n          this.secondsSinceStateTransition,\n          this.stage,\n          triggerValue,\n          this.valueOnTriggerChange\n        );\n        this.stage = envelopeValue.stage;\n        this.stageProgress = envelopeValue.stageProgress;\n        this.secondsSinceStateTransition = envelopeValue.secondsSinceStateTransition;\n        this.outputValue = envelopeValue.outputValue;\n        this.valueOnTriggerChange = envelopeValue.valueOnTriggerChange;\n        this.previousTriggerValue = triggerValue;\n\n        // only expecting one channel, but tolerating more in case\n        for (let channelIndex = 0; channelIndex < output.length; channelIndex++) {\n          const outputChannel = output[channelIndex];\n\n          outputChannel[sampleIndex] = this.outputValue;\n        }\n      }\n      return true;\n    }\n  }\n);\n","// based on https://webaudio.github.io/web-audio-api/#the-bitcrusher-node\nexport function crush(sample, bitDepth, fractionalDepthMode) {\n  if (bitDepth > 32) bitDepth = 32;\n  if (bitDepth < 1) bitDepth = 1;\n  if (fractionalDepthMode === 'trve') {\n    bitDepth = Math.floor(bitDepth);\n  }\n  let numberOfSteps = 2 ** bitDepth;\n  if (fractionalDepthMode === 'quantize-evenly') {\n    numberOfSteps = Math.floor(numberOfSteps);\n  }\n  const stepSize = 2 / numberOfSteps;\n  const max = 1 - stepSize;\n  if (sample >= max) return max;\n  if (sample <= -1) return -1;\n\n  return -1 + Math.floor((1 + sample) / stepSize) * stepSize;\n}\n","import { crush } from './crush-bit-fixed-point';\n\nregisterProcessor(\n  'bit-crusher-fixed-point',\n  class Noise extends AudioWorkletProcessor {\n    static get parameterDescriptors() {\n      return [\n        {\n          name: 'bitDepth',\n          defaultValue: 8,\n          minValue: 1,\n          maxValue: 32,\n          automationRate: 'a-rate'\n        }\n      ];\n    }\n\n    constructor() {\n      super();\n      this.fractionalBitDepthMode = 'quantize-evenly';\n      this.port.onmessage = this.handleMessage.bind(this);\n    }\n\n    handleMessage(event) {\n      if (\n        event.data &&\n        event.data.type === 'change-fractional-bit-depth-mode'\n      ) {\n        this.fractionalBitDepthMode = event.data.newMode;\n      }\n    }\n\n    process(inputs, outputs, parameters) {\n      // Only one input and output.\n      let input = inputs[0];\n      let output = outputs[0];\n      let bitDepth = parameters.bitDepth;\n      let bitDepthLength = bitDepth.length;\n      let getBitDepth =\n        bitDepthLength > 1 ? i => bitDepth[i] : () => bitDepth[0];\n\n      for (let channelIndex = 0; channelIndex < input.length; channelIndex++) {\n        const inputChannel = input[channelIndex];\n        const outputChannel = output[channelIndex];\n        for (\n          let sampleIndex = 0;\n          sampleIndex < inputChannel.length;\n          sampleIndex++\n        ) {\n          const inputSample = inputChannel[sampleIndex];\n          outputChannel[sampleIndex] = crush(\n            inputSample,\n            getBitDepth(sampleIndex),\n            this.fractionalBitDepthMode\n          );\n        }\n      }\n      return true;\n    }\n  }\n);\n","export const clockInTriggerStages = {\n  attack: 1,\n  high: 2,\n  release: 3,\n  low: 4\n};\n\nexport const clockStages = {\n  tick: 1,\n  tock: 0\n};\n\nexport const resetTriggerStages = {\n  reset: 1,\n  keepGoing: 0\n};\n\nexport function divideClockTicks(\n  state, // { stage, ticksPast, tocksPast },\n  { attackAfterTicks, releaseAfterTocks },\n  clockInStage,\n  resetTriggerStage\n) {\n  if (resetTriggerStage === resetTriggerStages.reset) {\n    state.stage = clockStages.tock;\n    state.tocksPast = 0;\n    state.ticksPast = attackAfterTicks - 1;\n  }\n  if (clockInStage === clockInTriggerStages.attack && state.stage === clockStages.tock) {\n    state.ticksPast++;\n    if (state.ticksPast >= attackAfterTicks) {\n      state.stage = clockStages.tick;\n      state.ticksPast -= attackAfterTicks;\n    }\n  }\n  if (clockInStage === clockInTriggerStages.release && state.stage === clockStages.tick) {\n    state.tocksPast++;\n    if (state.tocksPast >= releaseAfterTocks) {\n      state.stage = clockStages.tock;\n      state.tocksPast -= releaseAfterTocks;\n    }\n  }\n  return state;\n}\n","import {\n  clockInTriggerStages,\n  clockStages,\n  divideClockTicks,\n  resetTriggerStages\n} from './divide-clock-ticks';\nimport { getParameterValue } from './getParameterValue';\n\nregisterProcessor(\n  'clock-divider',\n  class ClockDivider extends AudioWorkletProcessor {\n    static get parameterDescriptors() {\n      return [\n        {\n          name: 'clockTrigger',\n          defaultValue: 0,\n          automationRate: 'a-rate'\n        },\n        {\n          name: 'resetTrigger',\n          defaultValue: 0,\n          automationRate: 'a-rate'\n        },\n        {\n          name: 'attackAfterTicks',\n          defaultValue: 1,\n          minValue: 1,\n          maxValue: 1e9,\n          automationRate: 'a-rate'\n        },\n        {\n          name: 'releaseAfterTocks',\n          defaultValue: 1,\n          minValue: 1,\n          maxValue: 1e9,\n          automationRate: 'a-rate'\n        }\n      ];\n    }\n    constructor(options) {\n      super(options);\n      this.state = {\n        stage: clockStages.tock,\n        // will be set according to params on reset\n        ticksPast: 0,\n        tocksPast: 0\n      };\n      this.userParams = { attackAfterTicks: 0, releaseAfterTocks: 0 };\n      this.initialReset = true;\n      this.port.onmessage = this.handleMessage.bind(this);\n      this.manualClockTriggerOn = false;\n      this.manualResetTriggerOn = false;\n      this.clockTriggerOn = false;\n      this.resetTriggerOn = false;\n    }\n\n    handleMessage(event) {\n      if (event.data && event.data.type === 'manual-clock-trigger') {\n        this.manualClockTriggerOn = event.data.value;\n      }\n      if (event.data && event.data.type === 'manual-reset-trigger') {\n        this.manualResetTriggerOn = event.data.value;\n      }\n    }\n\n    process(inputs, outputs, parameters) {\n      const output = outputs[0];\n\n      const getClockTriggerValue = this.manualClockTriggerOn\n        ? () => 1e9\n        : getParameterValue(parameters.clockTrigger, -1e9, 1e9);\n      const getResetTriggerValue =\n        this.manualResetTriggerOn || this.initialReset\n          ? () => {\n              this.initialReset = false;\n              return 1e9;\n            }\n          : getParameterValue(parameters.resetTrigger, -1e9, 1e9);\n      const getAttackAfterTicks = getParameterValue(parameters.attackAfterTicks, 1, 1e9);\n      const getReleaseAfterTocks = getParameterValue(parameters.releaseAfterTocks, 1, 1e9);\n\n      for (let sampleIndex = 0; sampleIndex < output[0].length; sampleIndex++) {\n        const clockTriggerValue = getClockTriggerValue(sampleIndex);\n        const resetTriggerValue = getResetTriggerValue(sampleIndex);\n        let clockTriggerStage;\n        if (clockTriggerValue > 0) {\n          if (this.clockTriggerOn) {\n            clockTriggerStage = clockInTriggerStages.high;\n          } else {\n            clockTriggerStage = clockInTriggerStages.attack;\n            this.port.postMessage({ type: 'clock-trigger-change', value: true });\n          }\n          this.clockTriggerOn = true;\n        } else {\n          if (this.clockTriggerOn) {\n            clockTriggerStage = clockInTriggerStages.release;\n            this.port.postMessage({ type: 'clock-trigger-change', value: false });\n          } else {\n            clockTriggerStage = clockInTriggerStages.low;\n          }\n          this.clockTriggerOn = false;\n        }\n        let resetTriggerStage = resetTriggerStages.keepGoing;\n\n        if (this.resetTriggerOn !== resetTriggerValue > 0) {\n          this.port.postMessage({ type: 'reset-trigger-change', value: resetTriggerValue > 0 });\n        }\n        if (resetTriggerValue > 0 && !this.resetTriggerOn) {\n          resetTriggerStage = resetTriggerStages.reset;\n        }\n        this.resetTriggerOn = resetTriggerValue > 0;\n\n        this.userParams.attackAfterTicks = getAttackAfterTicks(sampleIndex);\n        this.userParams.releaseAfterTocks = getReleaseAfterTocks(sampleIndex);\n\n        // mutates this.state\n        divideClockTicks(\n          this.state,\n          this.userParams,\n          clockTriggerStage,\n          resetTriggerStage\n        );\n        // only expecting one channel, but tolerating more in case\n        for (let channelIndex = 0; channelIndex < output.length; channelIndex++) {\n          const outputChannel = output[channelIndex];\n\n          outputChannel[sampleIndex] = this.state.stage;\n        }\n      }\n      return true;\n    }\n  }\n);\n"],"sourceRoot":""}