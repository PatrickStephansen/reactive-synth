{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/audio-worklet-processors/getParameterValue.js","webpack:///./node_modules/ramda/es/internal/_isPlaceholder.js","webpack:///./node_modules/ramda/es/internal/_curry1.js","webpack:///./node_modules/ramda/es/internal/_curry2.js","webpack:///./node_modules/ramda/es/internal/_curry3.js","webpack:///./node_modules/ramda/es/clamp.js","webpack:///./src/audio-worklet-processors/noise.js","webpack:///./src/audio-worklet-processors/inverse-gain.js","webpack:///./src/audio-worklet-processors/getEnvelopeValue.js","webpack:///./src/audio-worklet-processors/linear-change.js","webpack:///./src/audio-worklet-processors/envelope-generator.js","webpack:///./src/audio-worklet-processors/crush-bit-fixed-point.js","webpack:///./src/audio-worklet-processors/bit-crusher-fixed-point.js","webpack:///./src/audio-worklet-processors/divide-clock-ticks.js","webpack:///./src/audio-worklet-processors/clock-divider.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","getParameterValue","ramda__WEBPACK_IMPORTED_MODULE_0__","parameter","minValue","maxValue","sampleNumber","clampValue","length","_isPlaceholder","a","_curry1","fn","f1","arguments","apply","this","_curry2","f2","b","_b","_a","_curry3","f3","_c","clamp","min","max","Error","clampStep","clampSampleHold","clampTrigger","getNextValue","previousValue","stepMin","stepMax","stepSize","Math","random","registerProcessor","AudioWorkletProcessor","parameterDescriptors","defaultValue","automationRate","[object Object]","super","samplesHeld","isTriggerValueHigh","port","onmessage","handleMessage","manualTriggerOn","event","data","type","inputs","outputs","parameters","output","getStepMin","getStepMax","sampleHold","getSampleHold","nextValueTrigger","nextValueTriggerLength","getNextValueTrigger","triggerValue","postMessage","channel","input","divisor","getDivisor","getZeroDivisorOutput","zeroDivisorFallback","channelIndex","inputChannel","outputChannel","sampleIndex","inputSample","getEnvelopeValue","getValueAtTime","sampleRate","attackTime","attackValue","holdTime","decayTime","sustainValue","releaseTime","secondsSinceStateTransition","stage","valueOnTriggerChange","sampleTime","stageOutput","secondsSinceStateTransitionOutput","stageProgressOutput","valueOnTriggerChangeOutput","undefined","valueOutput","stageProgress","outputValue","startValue","startTime","endValue","endTime","currentTime","options","stages","state","previousTriggerValue","getTriggerValue","trigger","getAttackTime","getAttackValue","getHoldTime","getDecayTime","getSustainValue","getReleaseTime","envelopeValue","crush","sample","bitDepth","fractionalDepthMode","floor","numberOfSteps","fractionalBitDepthMode","newMode","getBitDepth","clockInTriggerStages","attack","high","release","low","clockStages","tick","tock","resetTriggerStages","reset","keepGoing","divideClockTicks","ticksPast","tocksPast","attackAfterTicks","releaseAfterTocks","clockInStage","resetTriggerStage","initialReset","manualClockTriggerOn","manualResetTriggerOn","clockTriggerOn","resetTriggerOn","getClockTriggerValue","clockTrigger","getResetTriggerValue","resetTrigger","getAttackAfterTicks","getReleaseAfterTocks","clockTriggerValue","resetTriggerValue","clockTriggerStage"],"mappings":"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","file":"worklets.00ed2b759eeb60fff4d0.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"./assets/audio-worklet-processors\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n","import { clamp } from 'ramda';\n\nexport const getParameterValue = (\n  parameter,\n  minValue,\n  maxValue\n) => sampleNumber => {\n  const clampValue = clamp(minValue, maxValue);\n  if (parameter.length > 1) {\n    return clampValue(parameter[sampleNumber]);\n  }\n  return clampValue(parameter[0]);\n};\n","export default function _isPlaceholder(a) {\n       return a != null && typeof a === 'object' && a['@@functional/placeholder'] === true;\n}","import _isPlaceholder from './_isPlaceholder.js';\n\n/**\n * Optimized internal one-arity curry function.\n *\n * @private\n * @category Function\n * @param {Function} fn The function to curry.\n * @return {Function} The curried function.\n */\nexport default function _curry1(fn) {\n  return function f1(a) {\n    if (arguments.length === 0 || _isPlaceholder(a)) {\n      return f1;\n    } else {\n      return fn.apply(this, arguments);\n    }\n  };\n}","import _curry1 from './_curry1.js';\nimport _isPlaceholder from './_isPlaceholder.js';\n\n/**\n * Optimized internal two-arity curry function.\n *\n * @private\n * @category Function\n * @param {Function} fn The function to curry.\n * @return {Function} The curried function.\n */\nexport default function _curry2(fn) {\n  return function f2(a, b) {\n    switch (arguments.length) {\n      case 0:\n        return f2;\n      case 1:\n        return _isPlaceholder(a) ? f2 : _curry1(function (_b) {\n          return fn(a, _b);\n        });\n      default:\n        return _isPlaceholder(a) && _isPlaceholder(b) ? f2 : _isPlaceholder(a) ? _curry1(function (_a) {\n          return fn(_a, b);\n        }) : _isPlaceholder(b) ? _curry1(function (_b) {\n          return fn(a, _b);\n        }) : fn(a, b);\n    }\n  };\n}","import _curry1 from './_curry1.js';\nimport _curry2 from './_curry2.js';\nimport _isPlaceholder from './_isPlaceholder.js';\n\n/**\n * Optimized internal three-arity curry function.\n *\n * @private\n * @category Function\n * @param {Function} fn The function to curry.\n * @return {Function} The curried function.\n */\nexport default function _curry3(fn) {\n  return function f3(a, b, c) {\n    switch (arguments.length) {\n      case 0:\n        return f3;\n      case 1:\n        return _isPlaceholder(a) ? f3 : _curry2(function (_b, _c) {\n          return fn(a, _b, _c);\n        });\n      case 2:\n        return _isPlaceholder(a) && _isPlaceholder(b) ? f3 : _isPlaceholder(a) ? _curry2(function (_a, _c) {\n          return fn(_a, b, _c);\n        }) : _isPlaceholder(b) ? _curry2(function (_b, _c) {\n          return fn(a, _b, _c);\n        }) : _curry1(function (_c) {\n          return fn(a, b, _c);\n        });\n      default:\n        return _isPlaceholder(a) && _isPlaceholder(b) && _isPlaceholder(c) ? f3 : _isPlaceholder(a) && _isPlaceholder(b) ? _curry2(function (_a, _b) {\n          return fn(_a, _b, c);\n        }) : _isPlaceholder(a) && _isPlaceholder(c) ? _curry2(function (_a, _c) {\n          return fn(_a, b, _c);\n        }) : _isPlaceholder(b) && _isPlaceholder(c) ? _curry2(function (_b, _c) {\n          return fn(a, _b, _c);\n        }) : _isPlaceholder(a) ? _curry1(function (_a) {\n          return fn(_a, b, c);\n        }) : _isPlaceholder(b) ? _curry1(function (_b) {\n          return fn(a, _b, c);\n        }) : _isPlaceholder(c) ? _curry1(function (_c) {\n          return fn(a, b, _c);\n        }) : fn(a, b, c);\n    }\n  };\n}","import _curry3 from './internal/_curry3.js';\n\n/**\n * Restricts a number to be within a range.\n *\n * Also works for other ordered types such as Strings and Dates.\n *\n * @func\n * @memberOf R\n * @since v0.20.0\n * @category Relation\n * @sig Ord a => a -> a -> a -> a\n * @param {Number} minimum The lower limit of the clamp (inclusive)\n * @param {Number} maximum The upper limit of the clamp (inclusive)\n * @param {Number} value Value to be clamped\n * @return {Number} Returns `minimum` when `val < minimum`, `maximum` when `val > maximum`, returns `val` otherwise\n * @example\n *\n *      R.clamp(1, 10, -5) // => 1\n *      R.clamp(1, 10, 15) // => 10\n *      R.clamp(1, 10, 4)  // => 4\n */\nvar clamp = /*#__PURE__*/_curry3(function clamp(min, max, value) {\n  if (min > max) {\n    throw new Error('min must not be greater than max in clamp(min, max, value)');\n  }\n  return value < min ? min : value > max ? max : value;\n});\nexport default clamp;","import { clamp } from 'ramda';\n\nconst clampStep = clamp(0, 1);\nconst clampSampleHold = clamp(0, 1000000);\nconst clampTrigger = clamp(0, 1);\n\nconst getNextValue = (previousValue, stepMin, stepMax) => {\n  const stepSize = Math.random() * (stepMax - stepMin) + stepMin;\n  const preferUp = Math.random() > 0.5;\n  if (preferUp) {\n    return previousValue + stepSize > 1 ? previousValue - stepSize : previousValue + stepSize;\n  } else {\n    return previousValue - stepSize < -1 ? previousValue + stepSize : previousValue - stepSize;\n  }\n};\n\nregisterProcessor(\n  'noise',\n  class Noise extends AudioWorkletProcessor {\n    static get parameterDescriptors() {\n      return [\n        {\n          name: 'stepMax',\n          defaultValue: 1,\n          minValue: 0,\n          maxValue: 1,\n          automationRate: 'a-rate'\n        },\n        {\n          name: 'stepMin',\n          defaultValue: 0,\n          minValue: 0,\n          maxValue: 1,\n          automationRate: 'a-rate'\n        },\n        {\n          name: 'sampleHold',\n          defaultValue: 1,\n          minValue: 0,\n          maxValue: 1000000,\n          automationRate: 'a-rate'\n        },\n        {\n          name: 'nextValueTrigger',\n          defaultValue: 0,\n          automationRate: 'a-rate'\n        }\n      ];\n    }\n\n    constructor() {\n      super();\n      // initializing to zero means max and min of 1 behaves differently on initial load\n      // start unbalanced so there is only one option for next sample in that case\n      this.previousValue = 0.1;\n      this.samplesHeld = 0;\n      this.isTriggerValueHigh = false;\n      this.port.onmessage = this.handleMessage.bind(this);\n      this.manualTriggerOn = false;\n    }\n\n    handleMessage(event) {\n      if (event.data && event.data.type === 'manual-trigger') {\n        this.manualTriggerOn = event.data.value;\n      }\n    }\n\n    process(inputs, outputs, parameters) {\n      // Get the first output.\n      let output = outputs[0];\n      let stepMin = parameters.stepMin;\n      let stepMinLength = stepMin.length;\n      let getStepMin = stepMinLength > 1 ? i => clampStep(stepMin[i]) : () => clampStep(stepMin[0]);\n      let stepMax = parameters.stepMax;\n      let stepMaxLength = stepMax.length;\n      let getStepMax = stepMaxLength > 1 ? i => clampStep(stepMax[i]) : () => clampStep(stepMax[0]);\n      let sampleHold = parameters.sampleHold;\n      let sampleHoldLength = sampleHold.length;\n      let getSampleHold =\n        sampleHoldLength > 1\n          ? i => clampSampleHold(sampleHold[i])\n          : () => clampSampleHold(sampleHold[0]);\n      let nextValueTrigger = parameters.nextValueTrigger;\n      let nextValueTriggerLength = nextValueTrigger.length;\n      let getNextValueTrigger = this.manualTriggerOn\n        ? () => 1e9\n        : nextValueTriggerLength > 1\n        ? i => clampTrigger(nextValueTrigger[i])\n        : () => clampTrigger(nextValueTrigger[0]);\n\n      for (let i = 0; i < output[0].length; ++i, ++this.samplesHeld) {\n        // recover from overflow\n        if (this.samplesHeld < 0) {\n          this.samplesHeld = 0;\n        }\n\n        const sampleHold = getSampleHold(i);\n\n        // keep playing previous sample forever if sampleHold < 1\n        if (sampleHold >= 1 && this.samplesHeld >= sampleHold) {\n          this.samplesHeld -= sampleHold;\n          this.previousValue = getNextValue(this.previousValue, getStepMin(i), getStepMax(i));\n        }\n        const triggerValue = getNextValueTrigger(i);\n        if (this.isTriggerValueHigh != triggerValue > 0) {\n          this.port.postMessage({ type: 'trigger-change', value: triggerValue > 0 });\n        }\n        if (!this.isTriggerValueHigh && triggerValue > 0) {\n          this.previousValue = getNextValue(this.previousValue, getStepMin(i), getStepMax(i));\n        }\n        this.isTriggerValueHigh = triggerValue > 0;\n        for (let channel = 0; channel < output.length; ++channel) {\n          output[channel][i] = this.previousValue;\n        }\n      }\n      return true;\n    }\n  }\n);\n","registerProcessor(\n  'inverse-gain',\n  class Noise extends AudioWorkletProcessor {\n    static get parameterDescriptors() {\n      return [\n        {\n          name: 'divisor',\n          defaultValue: 10,\n          automationRate: 'a-rate'\n        },\n        {\n          name: 'zeroDivisorFallback',\n          defaultValue: 0,\n          automationRate: 'a-rate'\n        }\n      ];\n    }\n\n    process(inputs, outputs, parameters) {\n      // Only one input and output.\n      let input = inputs[0];\n      let output = outputs[0];\n      let divisor = parameters.divisor;\n      let divisorLength = divisor.length;\n      let getDivisor = divisorLength > 1 ? i => divisor[i] : () => divisor[0];\n      let getZeroDivisorOutput =\n        parameters.zeroDivisorFallback.length > 1\n          ? i => parameters.zeroDivisorFallback[i]\n          : () => parameters.zeroDivisorFallback[0];\n\n      for (let channelIndex = 0; channelIndex < input.length; channelIndex++) {\n        const inputChannel = input[channelIndex];\n        const outputChannel = output[channelIndex];\n        for (\n          let sampleIndex = 0;\n          sampleIndex < inputChannel.length;\n          sampleIndex++\n        ) {\n          const inputSample = inputChannel[sampleIndex];\n          const divisor = getDivisor(sampleIndex);\n          if (divisor === 0) {\n            outputChannel[sampleIndex] = getZeroDivisorOutput(sampleIndex);\n          } else {\n            outputChannel[sampleIndex] = inputSample / divisor;\n          }\n        }\n      }\n      return true;\n    }\n  }\n);\n","// ASSUMPTION: this will be called every sample, so it's safe to always advance time by one sample\n// returns the value at end of the sample, so if attack time is 0, attack value will be returned on the sample of the recieved trigger\nexport const getEnvelopeValue = (\n  getValueAtTime,\n  sampleRate,\n  { attackTime, attackValue, holdTime, decayTime, sustainValue, releaseTime },\n  secondsSinceStateTransition,\n  stage,\n  triggerValue,\n  valueOnTriggerChange\n) => {\n  const sampleTime = 1 / sampleRate;\n  let stageOutput;\n  let secondsSinceStateTransitionOutput;\n  let stageProgressOutput = 0;\n  let valueOnTriggerChangeOutput = undefined;\n  let valueOutput = undefined;\n  if (stage === 'rest') {\n    if (triggerValue <= 0) {\n      stageOutput = 'rest';\n      secondsSinceStateTransitionOutput = secondsSinceStateTransition + sampleTime;\n      valueOutput = 0;\n    } else {\n      if (sampleTime < attackTime) {\n        stageOutput = 'attack';\n        secondsSinceStateTransitionOutput = sampleTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / attackTime;\n        valueOnTriggerChangeOutput = 0;\n        valueOutput = getValueAtTime(\n          0,\n          0,\n          attackValue,\n          attackTime,\n          secondsSinceStateTransitionOutput\n        );\n      } else if (sampleTime - attackTime < holdTime) {\n        stageOutput = 'hold';\n        secondsSinceStateTransitionOutput = sampleTime - attackTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / holdTime;\n        valueOutput = attackValue;\n      } else if (sampleTime - attackTime - holdTime < decayTime) {\n        stageOutput = 'decay';\n        secondsSinceStateTransitionOutput = sampleTime - attackTime - holdTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / decayTime;\n        valueOutput = getValueAtTime(\n          attackValue,\n          0,\n          sustainValue,\n          decayTime,\n          secondsSinceStateTransitionOutput\n        );\n      } else {\n        stageOutput = 'sustain';\n        secondsSinceStateTransitionOutput = sampleTime - attackTime - holdTime - decayTime;\n        valueOutput = sustainValue;\n      }\n    }\n  }\n  if (stage === 'attack') {\n    if (triggerValue <= 0) {\n      if (sampleTime < releaseTime) {\n        stageOutput = 'release';\n        secondsSinceStateTransitionOutput = sampleTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / releaseTime;\n        if (secondsSinceStateTransition < attackTime) {\n          valueOnTriggerChangeOutput = getValueAtTime(\n            valueOnTriggerChange || 0,\n            0,\n            attackValue,\n            attackTime,\n            secondsSinceStateTransition\n          );\n        } else if (secondsSinceStateTransition - attackTime < holdTime) {\n          valueOnTriggerChangeOutput = attackValue;\n        } else if (secondsSinceStateTransition - attackTime - holdTime < decayTime) {\n          valueOnTriggerChangeOutput = getValueAtTime(\n            attackValue,\n            0,\n            sustainValue,\n            decayTime,\n            secondsSinceStateTransition - attackTime - holdTime\n          );\n        } else {\n          valueOnTriggerChangeOutput = sustainValue;\n        }\n        valueOutput = getValueAtTime(\n          valueOnTriggerChangeOutput,\n          0,\n          0,\n          releaseTime,\n          secondsSinceStateTransitionOutput\n        );\n      } else {\n        stageOutput = 'rest';\n        secondsSinceStateTransitionOutput = sampleTime - releaseTime;\n        valueOutput = 0;\n      }\n    } else {\n      if (secondsSinceStateTransition + sampleTime < attackTime) {\n        stageOutput = 'attack';\n        secondsSinceStateTransitionOutput = secondsSinceStateTransition + sampleTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / attackTime;\n        valueOnTriggerChangeOutput = valueOnTriggerChange;\n        valueOutput = getValueAtTime(\n          valueOnTriggerChange || 0,\n          0,\n          attackValue,\n          attackTime,\n          secondsSinceStateTransitionOutput\n        );\n      } else if (secondsSinceStateTransition + sampleTime - attackTime < holdTime) {\n        stageOutput = 'hold';\n        secondsSinceStateTransitionOutput = secondsSinceStateTransition + sampleTime - attackTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / holdTime;\n        valueOutput = attackValue;\n      } else if (secondsSinceStateTransition + sampleTime - attackTime - holdTime < decayTime) {\n        stageOutput = 'decay';\n        secondsSinceStateTransitionOutput =\n          secondsSinceStateTransition + sampleTime - attackTime - holdTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / decayTime;\n        valueOutput = getValueAtTime(\n          attackValue,\n          0,\n          sustainValue,\n          decayTime,\n          secondsSinceStateTransitionOutput\n        );\n      } else {\n        stageOutput = 'sustain';\n        secondsSinceStateTransitionOutput =\n          secondsSinceStateTransition + sampleTime - attackTime - holdTime - decayTime;\n        valueOutput = sustainValue;\n      }\n    }\n  }\n  if (stage === 'hold') {\n    if (triggerValue <= 0) {\n      if (sampleTime < releaseTime) {\n        stageOutput = 'release';\n        secondsSinceStateTransitionOutput = sampleTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / releaseTime;\n        if (secondsSinceStateTransition < holdTime) {\n          valueOnTriggerChangeOutput = attackValue;\n        } else if (secondsSinceStateTransition - holdTime < decayTime) {\n          valueOnTriggerChangeOutput = getValueAtTime(\n            attackValue,\n            0,\n            sustainValue,\n            decayTime,\n            secondsSinceStateTransition - holdTime\n          );\n        } else {\n          valueOnTriggerChangeOutput = sustainValue;\n        }\n        valueOutput = getValueAtTime(\n          valueOnTriggerChangeOutput,\n          0,\n          0,\n          releaseTime,\n          secondsSinceStateTransitionOutput\n        );\n      } else {\n        stageOutput = 'rest';\n        secondsSinceStateTransitionOutput = sampleTime - releaseTime;\n        valueOutput = 0;\n      }\n    } else {\n      if (secondsSinceStateTransition + sampleTime < holdTime) {\n        stageOutput = 'hold';\n        secondsSinceStateTransitionOutput = secondsSinceStateTransition + sampleTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / holdTime;\n        valueOutput = attackValue;\n      } else if (secondsSinceStateTransition + sampleTime - holdTime < decayTime) {\n        stageOutput = 'decay';\n        secondsSinceStateTransitionOutput = secondsSinceStateTransition + sampleTime - holdTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / decayTime;\n        valueOutput = getValueAtTime(\n          attackValue,\n          0,\n          sustainValue,\n          decayTime,\n          secondsSinceStateTransitionOutput\n        );\n      } else {\n        stageOutput = 'sustain';\n        secondsSinceStateTransitionOutput =\n          secondsSinceStateTransition + sampleTime - holdTime - decayTime;\n        valueOutput = sustainValue;\n      }\n    }\n  }\n  if (stage === 'decay') {\n    if (triggerValue <= 0) {\n      if (sampleTime < releaseTime) {\n        stageOutput = 'release';\n        secondsSinceStateTransitionOutput = sampleTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / releaseTime;\n        if (secondsSinceStateTransition < decayTime) {\n          valueOnTriggerChangeOutput = getValueAtTime(\n            attackValue,\n            0,\n            sustainValue,\n            decayTime,\n            secondsSinceStateTransition\n          );\n        } else {\n          valueOnTriggerChangeOutput = sustainValue;\n        }\n        valueOutput = getValueAtTime(\n          valueOnTriggerChangeOutput,\n          0,\n          0,\n          releaseTime,\n          secondsSinceStateTransitionOutput\n        );\n      } else {\n        stageOutput = 'rest';\n        secondsSinceStateTransitionOutput = sampleTime - releaseTime;\n        valueOutput = 0;\n      }\n    } else {\n      if (secondsSinceStateTransition + sampleTime < decayTime) {\n        stageOutput = 'decay';\n        secondsSinceStateTransitionOutput = secondsSinceStateTransition + sampleTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / decayTime;\n        valueOutput = getValueAtTime(\n          attackValue,\n          0,\n          sustainValue,\n          decayTime,\n          secondsSinceStateTransitionOutput\n        );\n      } else {\n        stageOutput = 'sustain';\n        secondsSinceStateTransitionOutput = secondsSinceStateTransition + sampleTime - decayTime;\n        valueOutput = sustainValue;\n      }\n    }\n  }\n  if (stage === 'sustain') {\n    if (triggerValue <= 0) {\n      if (sampleTime < releaseTime) {\n        stageOutput = 'release';\n        secondsSinceStateTransitionOutput = sampleTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / releaseTime;\n        valueOnTriggerChangeOutput = sustainValue;\n        valueOutput = getValueAtTime(\n          valueOnTriggerChangeOutput,\n          0,\n          0,\n          releaseTime,\n          secondsSinceStateTransitionOutput\n        );\n      } else {\n        stageOutput = 'rest';\n        secondsSinceStateTransitionOutput = sampleTime - releaseTime;\n        valueOutput = 0;\n      }\n    } else {\n      stageOutput = 'sustain';\n      secondsSinceStateTransitionOutput = secondsSinceStateTransition + sampleTime;\n      valueOutput = sustainValue;\n    }\n  }\n  if (stage === 'release') {\n    if (triggerValue <= 0) {\n      if (secondsSinceStateTransition + sampleTime < releaseTime) {\n        stageOutput = 'release';\n        secondsSinceStateTransitionOutput = secondsSinceStateTransition + sampleTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / releaseTime;\n        valueOnTriggerChangeOutput = valueOnTriggerChange;\n        valueOutput = getValueAtTime(\n          valueOnTriggerChangeOutput,\n          0,\n          0,\n          releaseTime,\n          secondsSinceStateTransitionOutput\n        );\n      } else {\n        stageOutput = 'rest';\n        secondsSinceStateTransitionOutput = secondsSinceStateTransition + sampleTime - releaseTime;\n        valueOutput = 0;\n      }\n    } else {\n      if (sampleTime < attackTime) {\n        stageOutput = 'attack';\n        secondsSinceStateTransitionOutput = sampleTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / attackTime;\n        valueOnTriggerChangeOutput = getValueAtTime(valueOnTriggerChange || 0, 0, 0, releaseTime, secondsSinceStateTransition);\n        valueOutput = getValueAtTime(\n          valueOnTriggerChangeOutput,\n          0,\n          attackValue,\n          attackTime,\n          secondsSinceStateTransitionOutput\n        );\n      } else if (sampleTime - attackTime < holdTime) {\n        stageOutput = 'hold';\n        secondsSinceStateTransitionOutput = sampleTime - attackTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / holdTime;\n        valueOutput = attackValue;\n      } else if (sampleTime - attackTime - holdTime < decayTime) {\n        stageOutput = 'decay';\n        secondsSinceStateTransitionOutput = sampleTime - attackTime - holdTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / decayTime;\n        valueOutput = getValueAtTime(\n          attackValue,\n          0,\n          sustainValue,\n          decayTime,\n          secondsSinceStateTransitionOutput\n        );\n      } else {\n        stageOutput = 'sustain';\n        secondsSinceStateTransitionOutput = sampleTime - attackTime - holdTime - decayTime;\n        valueOutput = sustainValue;\n      }\n    }\n  }\n  return {\n    stage: stageOutput,\n    stageProgress: stageProgressOutput,\n    secondsSinceStateTransition: secondsSinceStateTransitionOutput,\n    valueOnTriggerChange: valueOnTriggerChangeOutput,\n    outputValue: valueOutput\n  };\n};\n","export function getValueAtTime(\n  startValue,\n  startTime,\n  endValue,\n  endTime,\n  currentTime\n) {\n  if (startTime >= endTime) {\n    startTime = endTime;\n  }\n  if (currentTime >= endTime) {\n    return endValue;\n  }\n  if (currentTime <= startTime) {\n    return startValue;\n  }\n\n  const gradient = (endValue - startValue) / (endTime - startTime);\n  return startValue + (currentTime - startTime) * gradient;\n}\n","import { getParameterValue } from './getParameterValue';\nimport { getEnvelopeValue } from './getEnvelopeValue';\nimport { getValueAtTime } from './linear-change';\n\nregisterProcessor(\n  'envelope-generator',\n  class EnvelopeGenerator extends AudioWorkletProcessor {\n    static get parameterDescriptors() {\n      return [\n        {\n          name: 'trigger',\n          defaultValue: 0,\n          automationRate: 'a-rate'\n        },\n        {\n          name: 'attackValue',\n          defaultValue: 1,\n          minValue: 0,\n          maxValue: 1,\n          automationRate: 'a-rate'\n        },\n        {\n          name: 'attackTime',\n          defaultValue: 0.001,\n          minValue: 0,\n          maxValue: 10,\n          automationRate: 'a-rate'\n        },\n        {\n          name: 'holdTime',\n          minValue: 0,\n          defaultValue: 0.0625,\n          maxValue: 10,\n          automationRate: 'a-rate'\n        },\n        {\n          name: 'decayTime',\n          defaultValue: 0.125,\n          minValue: 0,\n          maxValue: 10,\n          automationRate: 'a-rate'\n        },\n        {\n          name: 'sustainValue',\n          defaultValue: 0.25,\n          minValue: 0,\n          maxValue: 1,\n          automationRate: 'a-rate'\n        },\n        {\n          name: 'releaseTime',\n          defaultValue: 0.25,\n          minValue: 0,\n          maxValue: 10\n        }\n      ];\n    }\n\n    constructor(options) {\n      super(options);\n      this.stages = ['rest', 'attack', 'hold', 'decay', 'sustain', 'release'];\n      this.stage = this.stages[0];\n      // stageProgress advances from 0 to 1 to show progress of stage\n      this.stageProgress = 0;\n      this.secondsSinceStateTransition = 0;\n      this.port.onmessage = this.handleMessage.bind(this);\n      this.state = {\n        attackTime: 0.001,\n        attackValue: 1,\n        holdTime: 0.0625,\n        decayTime: 0.125,\n        sustainValue: 0.25,\n        releaseTime: 0.25\n      };\n      this.sampleRate = options.sampleRate || 44100;\n      this.outputValue;\n      this.valueOnTriggerChange = undefined;\n      this.manualTriggerOn = false;\n      this.previousTriggerValue = 0;\n    }\n\n    handleMessage(event) {\n      if (event.data && event.data.type === 'getState') {\n        this.port.postMessage({\n          type: 'state',\n          state: {\n            stage: this.stage,\n            stageProgress: this.stageProgress,\n            outputValue: this.outputValue\n          }\n        });\n      }\n      if (event.data && event.data.type === 'manual-trigger') {\n        this.manualTriggerOn = event.data.value;\n      }\n    }\n\n    process(inputs, outputs, parameters) {\n      // Only one output.\n      let output = outputs[0];\n      const getTriggerValue = this.manualTriggerOn\n        ? () => 1e9\n        : getParameterValue(parameters.trigger, -1e9, 1e9);\n      const getAttackTime = getParameterValue(parameters.attackTime, 0, 10);\n      const getAttackValue = getParameterValue(parameters.attackValue, 0, 1);\n      const getHoldTime = getParameterValue(parameters.holdTime, 0, 10);\n      const getDecayTime = getParameterValue(parameters.decayTime, 0, 10);\n      const getSustainValue = getParameterValue(parameters.sustainValue, 0, 1);\n      const getReleaseTime = getParameterValue(parameters.releaseTime, 0, 10);\n\n      for (let sampleIndex = 0; sampleIndex < output[0].length; sampleIndex++) {\n        this.state = {\n          attackTime: getAttackTime(sampleIndex),\n          attackValue: getAttackValue(sampleIndex),\n          holdTime: getHoldTime(sampleIndex),\n          decayTime: getDecayTime(sampleIndex),\n          sustainValue: getSustainValue(sampleIndex),\n          releaseTime: getReleaseTime(sampleIndex)\n        };\n        const triggerValue = getTriggerValue(sampleIndex);\n\n        if (triggerValue > 0 != this.previousTriggerValue > 0) {\n          this.port.postMessage({ type: 'trigger-change', value: triggerValue > 0 });\n        }\n\n        const envelopeValue = getEnvelopeValue(\n          getValueAtTime,\n          this.sampleRate,\n          this.state,\n          this.secondsSinceStateTransition,\n          this.stage,\n          triggerValue,\n          this.valueOnTriggerChange\n        );\n        this.stage = envelopeValue.stage;\n        this.stageProgress = envelopeValue.stageProgress;\n        this.secondsSinceStateTransition = envelopeValue.secondsSinceStateTransition;\n        this.outputValue = envelopeValue.outputValue;\n        this.valueOnTriggerChange = envelopeValue.valueOnTriggerChange;\n        this.previousTriggerValue = triggerValue;\n\n        // only expecting one channel, but tolerating more in case\n        for (let channelIndex = 0; channelIndex < output.length; channelIndex++) {\n          const outputChannel = output[channelIndex];\n\n          outputChannel[sampleIndex] = this.outputValue;\n        }\n      }\n      return true;\n    }\n  }\n);\n","// based on https://webaudio.github.io/web-audio-api/#the-bitcrusher-node\nexport function crush(sample, bitDepth, fractionalDepthMode) {\n  if (bitDepth > 32) bitDepth = 32;\n  if (bitDepth < 1) bitDepth = 1;\n  if (fractionalDepthMode === 'trve') {\n    bitDepth = Math.floor(bitDepth);\n  }\n  let numberOfSteps = 2 ** bitDepth;\n  if (fractionalDepthMode === 'quantize-evenly') {\n    numberOfSteps = Math.floor(numberOfSteps);\n  }\n  const stepSize = 2 / numberOfSteps;\n  const max = 1 - stepSize;\n  if (sample >= max) return max;\n  if (sample <= -1) return -1;\n\n  return -1 + Math.floor((1 + sample) / stepSize) * stepSize;\n}\n","import { crush } from './crush-bit-fixed-point';\n\nregisterProcessor(\n  'bit-crusher-fixed-point',\n  class Noise extends AudioWorkletProcessor {\n    static get parameterDescriptors() {\n      return [\n        {\n          name: 'bitDepth',\n          defaultValue: 8,\n          minValue: 1,\n          maxValue: 32,\n          automationRate: 'a-rate'\n        }\n      ];\n    }\n\n    constructor() {\n      super();\n      this.fractionalBitDepthMode = 'quantize-evenly';\n      this.port.onmessage = this.handleMessage.bind(this);\n    }\n\n    handleMessage(event) {\n      if (\n        event.data &&\n        event.data.type === 'change-fractional-bit-depth-mode'\n      ) {\n        this.fractionalBitDepthMode = event.data.newMode;\n      }\n    }\n\n    process(inputs, outputs, parameters) {\n      // Only one input and output.\n      let input = inputs[0];\n      let output = outputs[0];\n      let bitDepth = parameters.bitDepth;\n      let bitDepthLength = bitDepth.length;\n      let getBitDepth =\n        bitDepthLength > 1 ? i => bitDepth[i] : () => bitDepth[0];\n\n      for (let channelIndex = 0; channelIndex < input.length; channelIndex++) {\n        const inputChannel = input[channelIndex];\n        const outputChannel = output[channelIndex];\n        for (\n          let sampleIndex = 0;\n          sampleIndex < inputChannel.length;\n          sampleIndex++\n        ) {\n          const inputSample = inputChannel[sampleIndex];\n          outputChannel[sampleIndex] = crush(\n            inputSample,\n            getBitDepth(sampleIndex),\n            this.fractionalBitDepthMode\n          );\n        }\n      }\n      return true;\n    }\n  }\n);\n","import { compose } from 'ramda';\n\nexport const clockInTriggerStages = {\n  attack: 1,\n  high: 2,\n  release: 3,\n  low: 4\n};\n\nexport const clockStages = {\n  tick: 1,\n  tock: 0\n};\n\nexport const resetTriggerStages = {\n  reset: 1,\n  keepGoing: 0\n};\n\nexport function divideClockTicks(\n  { stage, ticksPast, tocksPast },\n  { attackAfterTicks, releaseAfterTocks },\n  clockInStage,\n  resetTriggerStage\n) {\n  if (resetTriggerStage === resetTriggerStages.reset) {\n    stage = clockStages.tock;\n    tocksPast = 0;\n    ticksPast = attackAfterTicks - 1;\n  }\n  if (clockInStage === clockInTriggerStages.attack && stage === clockStages.tock) {\n    ticksPast++;\n    if (ticksPast >= attackAfterTicks) {\n      stage = clockStages.tick;\n      ticksPast -= attackAfterTicks;\n    }\n  }\n  if (clockInStage === clockInTriggerStages.release && stage === clockStages.tick) {\n    tocksPast++;\n    if (tocksPast >= releaseAfterTocks) {\n      stage = clockStages.tock;\n      tocksPast -= releaseAfterTocks;\n    }\n  }\n  return { stage, ticksPast, tocksPast };\n}\n","import {\n  clockInTriggerStages,\n  clockStages,\n  divideClockTicks,\n  resetTriggerStages\n} from './divide-clock-ticks';\nimport { getParameterValue } from './getParameterValue';\n\nregisterProcessor(\n  'clock-divider',\n  class ClockDivider extends AudioWorkletProcessor {\n    static get parameterDescriptors() {\n      return [\n        {\n          name: 'clockTrigger',\n          defaultValue: 0,\n          automationRate: 'a-rate'\n        },\n        {\n          name: 'resetTrigger',\n          defaultValue: 0,\n          automationRate: 'a-rate'\n        },\n        {\n          name: 'attackAfterTicks',\n          defaultValue: 1,\n          minValue: 1,\n          maxValue: 1e9,\n          automationRate: 'a-rate'\n        },\n        {\n          name: 'releaseAfterTocks',\n          defaultValue: 1,\n          minValue: 1,\n          maxValue: 1e9,\n          automationRate: 'a-rate'\n        }\n      ];\n    }\n    constructor(options) {\n      super(options);\n      this.state = {\n        stage: clockStages.tock,\n        // will be set according to params on reset\n        ticksPast: 0,\n        tocksPast: 0\n      };\n      this.initialReset = true;\n      this.port.onmessage = this.handleMessage.bind(this);\n      this.manualClockTriggerOn = false;\n      this.manualResetTriggerOn = false;\n      this.clockTriggerOn = false;\n      this.resetTriggerOn = false;\n    }\n\n    handleMessage(event) {\n      if (event.data && event.data.type === 'manual-clock-trigger') {\n        this.manualClockTriggerOn = event.data.value;\n      }\n      if (event.data && event.data.type === 'manual-reset-trigger') {\n        this.manualResetTriggerOn = event.data.value;\n      }\n    }\n\n    process(inputs, outputs, parameters) {\n      const output = outputs[0];\n\n      const getClockTriggerValue = this.manualClockTriggerOn\n        ? () => 1e9\n        : getParameterValue(parameters.clockTrigger, -1e9, 1e9);\n      const getResetTriggerValue =\n        this.manualResetTriggerOn || this.initialReset\n          ? () => {\n              this.initialReset = false;\n              return 1e9;\n            }\n          : getParameterValue(parameters.resetTrigger, -1e9, 1e9);\n      const getAttackAfterTicks = getParameterValue(parameters.attackAfterTicks, 1, 1e9);\n      const getReleaseAfterTocks = getParameterValue(parameters.releaseAfterTocks, 1, 1e9);\n\n      for (let sampleIndex = 0; sampleIndex < output[0].length; sampleIndex++) {\n        const clockTriggerValue = getClockTriggerValue(sampleIndex);\n        const resetTriggerValue = getResetTriggerValue(sampleIndex);\n        let clockTriggerStage;\n        if (clockTriggerValue > 0) {\n          if (this.clockTriggerOn) {\n            clockTriggerStage = clockInTriggerStages.high;\n          } else {\n            clockTriggerStage = clockInTriggerStages.attack;\n            this.port.postMessage({ type: 'clock-trigger-change', value: true });\n          }\n          this.clockTriggerOn = true;\n        } else {\n          if (this.clockTriggerOn) {\n            clockTriggerStage = clockInTriggerStages.release;\n            this.port.postMessage({ type: 'clock-trigger-change', value: false });\n          } else {\n            clockTriggerStage = clockInTriggerStages.low;\n          }\n          this.clockTriggerOn = false;\n        }\n        let resetTriggerStage = resetTriggerStages.keepGoing;\n\n        if (this.resetTriggerOn !== resetTriggerValue > 0) {\n          this.port.postMessage({ type: 'reset-trigger-change', value: resetTriggerValue > 0 });\n        }\n        if (resetTriggerValue > 0 && !this.resetTriggerOn) {\n          resetTriggerStage = resetTriggerStages.reset;\n        }\n        this.resetTriggerOn = resetTriggerValue > 0;\n\n        this.state = divideClockTicks(\n          this.state,\n          {\n            attackAfterTicks: getAttackAfterTicks(sampleIndex),\n            releaseAfterTocks: getReleaseAfterTocks(sampleIndex)\n          },\n          clockTriggerStage,\n          resetTriggerStage\n        );\n        // only expecting one channel, but tolerating more in case\n        for (let channelIndex = 0; channelIndex < output.length; channelIndex++) {\n          const outputChannel = output[channelIndex];\n\n          outputChannel[sampleIndex] = this.state.stage;\n        }\n      }\n      return true;\n    }\n  }\n);\n"],"sourceRoot":""}