{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/ramda/es/internal/_isPlaceholder.js","webpack:///./node_modules/ramda/es/internal/_curry1.js","webpack:///./node_modules/ramda/es/internal/_curry2.js","webpack:///./node_modules/ramda/es/internal/_curry3.js","webpack:///./node_modules/ramda/es/clamp.js","webpack:///./src/audio-worklet-processors/noise.js","webpack:///./src/audio-worklet-processors/inverse-gain.js","webpack:///./src/audio-worklet-processors/getParameterValue.js","webpack:///./src/audio-worklet-processors/linear-change.js","webpack:///./src/audio-worklet-processors/getEnvelopeValue.js","webpack:///./src/audio-worklet-processors/envelope-generator.js","webpack:///./src/audio-worklet-processors/crush-bit-fixed-point.js","webpack:///./src/audio-worklet-processors/bit-crusher-fixed-point.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","_isPlaceholder","a","_curry1","fn","f1","arguments","length","apply","this","_curry2","f2","b","_b","_a","_curry3","f3","_c","clamp","min","max","Error","__webpack_exports__","ramda__WEBPACK_IMPORTED_MODULE_0__","clampStep","clampSampleHold","clampTrigger","getNextValue","previousValue","stepMin","stepMax","stepSize","Math","random","registerProcessor","AudioWorkletProcessor","parameterDescriptors","defaultValue","minValue","maxValue","automationRate","[object Object]","super","samplesHeld","isTriggerValueHigh","inputs","outputs","parameters","output","getStepMin","getStepMax","sampleHold","getSampleHold","nextValueTrigger","getNextValueTrigger","channel","input","divisor","getDivisor","getZeroDivisorOutput","zeroDivisorFallback","channelIndex","inputChannel","outputChannel","sampleIndex","inputSample","getParameterValue","parameter","sampleNumber","clampValue","getValueAtTime","startValue","startTime","endValue","endTime","currentTime","getEnvelopeValue","sampleRate","attackTime","attackValue","holdTime","decayTime","sustainValue","releaseTime","secondsSinceStateTransition","stage","triggerValue","valueOnRelease","sampleTime","stageOutput","secondsSinceStateTransitionOutput","stageProgressOutput","valueOnReleaseOutput","undefined","valueOutput","stageProgress","outputValue","options","stages","port","onmessage","handleMessage","state","event","data","type","postMessage","getAttackTime","getAttackValue","getHoldTime","getDecayTime","getSustainValue","getReleaseTime","envelopeValue","crush","sample","bitDepth","fractionalDepthMode","floor","numberOfSteps","fractionalBitDepthMode","newMode","getBitDepth"],"mappings":"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","file":"worklets.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"./assets/audio-worklet-processors\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","export default function _isPlaceholder(a) {\n       return a != null && typeof a === 'object' && a['@@functional/placeholder'] === true;\n}","import _isPlaceholder from './_isPlaceholder.js';\n\n/**\n * Optimized internal one-arity curry function.\n *\n * @private\n * @category Function\n * @param {Function} fn The function to curry.\n * @return {Function} The curried function.\n */\nexport default function _curry1(fn) {\n  return function f1(a) {\n    if (arguments.length === 0 || _isPlaceholder(a)) {\n      return f1;\n    } else {\n      return fn.apply(this, arguments);\n    }\n  };\n}","import _curry1 from './_curry1.js';\nimport _isPlaceholder from './_isPlaceholder.js';\n\n/**\n * Optimized internal two-arity curry function.\n *\n * @private\n * @category Function\n * @param {Function} fn The function to curry.\n * @return {Function} The curried function.\n */\nexport default function _curry2(fn) {\n  return function f2(a, b) {\n    switch (arguments.length) {\n      case 0:\n        return f2;\n      case 1:\n        return _isPlaceholder(a) ? f2 : _curry1(function (_b) {\n          return fn(a, _b);\n        });\n      default:\n        return _isPlaceholder(a) && _isPlaceholder(b) ? f2 : _isPlaceholder(a) ? _curry1(function (_a) {\n          return fn(_a, b);\n        }) : _isPlaceholder(b) ? _curry1(function (_b) {\n          return fn(a, _b);\n        }) : fn(a, b);\n    }\n  };\n}","import _curry1 from './_curry1.js';\nimport _curry2 from './_curry2.js';\nimport _isPlaceholder from './_isPlaceholder.js';\n\n/**\n * Optimized internal three-arity curry function.\n *\n * @private\n * @category Function\n * @param {Function} fn The function to curry.\n * @return {Function} The curried function.\n */\nexport default function _curry3(fn) {\n  return function f3(a, b, c) {\n    switch (arguments.length) {\n      case 0:\n        return f3;\n      case 1:\n        return _isPlaceholder(a) ? f3 : _curry2(function (_b, _c) {\n          return fn(a, _b, _c);\n        });\n      case 2:\n        return _isPlaceholder(a) && _isPlaceholder(b) ? f3 : _isPlaceholder(a) ? _curry2(function (_a, _c) {\n          return fn(_a, b, _c);\n        }) : _isPlaceholder(b) ? _curry2(function (_b, _c) {\n          return fn(a, _b, _c);\n        }) : _curry1(function (_c) {\n          return fn(a, b, _c);\n        });\n      default:\n        return _isPlaceholder(a) && _isPlaceholder(b) && _isPlaceholder(c) ? f3 : _isPlaceholder(a) && _isPlaceholder(b) ? _curry2(function (_a, _b) {\n          return fn(_a, _b, c);\n        }) : _isPlaceholder(a) && _isPlaceholder(c) ? _curry2(function (_a, _c) {\n          return fn(_a, b, _c);\n        }) : _isPlaceholder(b) && _isPlaceholder(c) ? _curry2(function (_b, _c) {\n          return fn(a, _b, _c);\n        }) : _isPlaceholder(a) ? _curry1(function (_a) {\n          return fn(_a, b, c);\n        }) : _isPlaceholder(b) ? _curry1(function (_b) {\n          return fn(a, _b, c);\n        }) : _isPlaceholder(c) ? _curry1(function (_c) {\n          return fn(a, b, _c);\n        }) : fn(a, b, c);\n    }\n  };\n}","import _curry3 from './internal/_curry3.js';\n\n/**\n * Restricts a number to be within a range.\n *\n * Also works for other ordered types such as Strings and Dates.\n *\n * @func\n * @memberOf R\n * @since v0.20.0\n * @category Relation\n * @sig Ord a => a -> a -> a -> a\n * @param {Number} minimum The lower limit of the clamp (inclusive)\n * @param {Number} maximum The upper limit of the clamp (inclusive)\n * @param {Number} value Value to be clamped\n * @return {Number} Returns `minimum` when `val < minimum`, `maximum` when `val > maximum`, returns `val` otherwise\n * @example\n *\n *      R.clamp(1, 10, -5) // => 1\n *      R.clamp(1, 10, 15) // => 10\n *      R.clamp(1, 10, 4)  // => 4\n */\nvar clamp = /*#__PURE__*/_curry3(function clamp(min, max, value) {\n  if (min > max) {\n    throw new Error('min must not be greater than max in clamp(min, max, value)');\n  }\n  return value < min ? min : value > max ? max : value;\n});\nexport default clamp;","import { clamp } from 'ramda';\n\nconst clampStep = clamp(0, 1);\nconst clampSampleHold = clamp(0, 1000000);\nconst clampTrigger = clamp(0, 1);\n\nconst getNextValue = (previousValue, stepMin, stepMax) => {\n  const stepSize = Math.random() * (stepMax - stepMin) + stepMin;\n  const preferUp = Math.random() > 0.5;\n  if (preferUp) {\n    return previousValue + stepSize > 1\n      ? previousValue - stepSize\n      : previousValue + stepSize;\n  } else {\n    return previousValue - stepSize < -1\n      ? previousValue + stepSize\n      : previousValue - stepSize;\n  }\n};\n\nregisterProcessor(\n  'noise',\n  class Noise extends AudioWorkletProcessor {\n    static get parameterDescriptors() {\n      return [\n        {\n          name: 'stepMax',\n          defaultValue: 1,\n          minValue: 0,\n          maxValue: 1,\n          automationRate: 'a-rate'\n        },\n        {\n          name: 'stepMin',\n          defaultValue: 0,\n          minValue: 0,\n          maxValue: 1,\n          automationRate: 'a-rate'\n        },\n        {\n          name: 'sampleHold',\n          defaultValue: 1,\n          minValue: 0,\n          maxValue: 1000000,\n          automationRate: 'a-rate'\n        },\n        {\n          name: 'nextValueTrigger',\n          defaultValue: 0,\n          automationRate: 'a-rate'\n        }\n      ];\n    }\n    constructor() {\n      super();\n      // initializing to zero means max and min of 1 behaves differently on initial load\n      // start unbalanced so there is only one option for next sample in that case\n      this.previousValue = 0.1;\n      this.samplesHeld = 0;\n      this.isTriggerValueHigh = false;\n    }\n    process(inputs, outputs, parameters) {\n      // Get the first output.\n      let output = outputs[0];\n      let stepMin = parameters.stepMin;\n      let stepMinLength = stepMin.length;\n      let getStepMin =\n        stepMinLength > 1\n          ? i => clampStep(stepMin[i])\n          : () => clampStep(stepMin[0]);\n      let stepMax = parameters.stepMax;\n      let stepMaxLength = stepMax.length;\n      let getStepMax =\n        stepMaxLength > 1\n          ? i => clampStep(stepMax[i])\n          : () => clampStep(stepMax[0]);\n      let sampleHold = parameters.sampleHold;\n      let sampleHoldLength = sampleHold.length;\n      let getSampleHold =\n        sampleHoldLength > 1\n          ? i => clampSampleHold(sampleHold[i])\n          : () => clampSampleHold(sampleHold[0]);\n      let nextValueTrigger = parameters.nextValueTrigger;\n      let nextValueTriggerLength = nextValueTrigger.length;\n      let getNextValueTrigger =\n        nextValueTriggerLength > 1\n          ? i => clampTrigger(nextValueTrigger[i])\n          : () => clampTrigger(nextValueTrigger[0]);\n\n      for (let i = 0; i < output[0].length; ++i, ++this.samplesHeld) {\n        // recover from overflow\n        if (this.samplesHeld < 0) {\n          this.samplesHeld = 0;\n        }\n\n        const sampleHold = getSampleHold(i);\n\n        // keep playing previous sample forever if sampleHold < 1\n        if (sampleHold >= 1 && this.samplesHeld >= sampleHold) {\n          this.samplesHeld -= sampleHold;\n          this.previousValue = getNextValue(\n            this.previousValue,\n            getStepMin(i),\n            getStepMax(i)\n          );\n        }\n        if (!this.isTriggerValueHigh && getNextValueTrigger(i) > 0) {\n          this.previousValue = getNextValue(\n            this.previousValue,\n            getStepMin(i),\n            getStepMax(i)\n          );\n        }\n        this.isTriggerValueHigh = getNextValueTrigger(i) > 0;\n        for (let channel = 0; channel < output.length; ++channel) {\n          output[channel][i] = this.previousValue;\n        }\n      }\n      return true;\n    }\n  }\n);\n","registerProcessor(\n  'inverse-gain',\n  class Noise extends AudioWorkletProcessor {\n    static get parameterDescriptors() {\n      return [\n        {\n          name: 'divisor',\n          defaultValue: 10,\n          automationRate: 'a-rate'\n        },\n        {\n          name: 'zeroDivisorFallback',\n          defaultValue: 0,\n          automationRate: 'a-rate'\n        }\n      ];\n    }\n\n    process(inputs, outputs, parameters) {\n      // Only one input and output.\n      let input = inputs[0];\n      let output = outputs[0];\n      let divisor = parameters.divisor;\n      let divisorLength = divisor.length;\n      let getDivisor = divisorLength > 1 ? i => divisor[i] : () => divisor[0];\n      let getZeroDivisorOutput =\n        parameters.zeroDivisorFallback.length > 1\n          ? i => parameters.zeroDivisorFallback[i]\n          : () => parameters.zeroDivisorFallback[0];\n\n      for (let channelIndex = 0; channelIndex < input.length; channelIndex++) {\n        const inputChannel = input[channelIndex];\n        const outputChannel = output[channelIndex];\n        for (\n          let sampleIndex = 0;\n          sampleIndex < inputChannel.length;\n          sampleIndex++\n        ) {\n          const inputSample = inputChannel[sampleIndex];\n          const divisor = getDivisor(sampleIndex);\n          if (divisor === 0) {\n            outputChannel[sampleIndex] = getZeroDivisorOutput(sampleIndex);\n          } else {\n            outputChannel[sampleIndex] = inputSample / divisor;\n          }\n        }\n      }\n      return true;\n    }\n  }\n);\n","import { clamp } from 'ramda';\n\nexport const getParameterValue = (\n  parameter,\n  minValue,\n  maxValue\n) => sampleNumber => {\n  const clampValue = clamp(minValue, maxValue);\n  if (parameter.length > 1) {\n    return clampValue(parameter[sampleNumber]);\n  }\n  return clampValue(parameter[0]);\n};\n","export function getValueAtTime(\n  startValue,\n  startTime,\n  endValue,\n  endTime,\n  currentTime\n) {\n  if (startTime >= endTime) {\n    startTime = endTime;\n  }\n  if (currentTime >= endTime) {\n    return endValue;\n  }\n  if (currentTime <= startTime) {\n    return startValue;\n  }\n\n  const gradient = (endValue - startValue) / (endTime - startTime);\n  return startValue + (currentTime - startTime) * gradient;\n}\n","import { getValueAtTime } from './linear-change';\n\n// ASSUMPTION: this will be called every sample, so it's safe to always advance time by one sample\n// returns the value at end of the sample, so if attack time is 0, attack value will be returned on the sample of the recieved trigger\nexport const getEnvelopeValue = (\n  sampleRate,\n  { attackTime, attackValue, holdTime, decayTime, sustainValue, releaseTime },\n  secondsSinceStateTransition,\n  stage,\n  triggerValue,\n  valueOnRelease\n) => {\n  const sampleTime = 1 / sampleRate;\n  let stageOutput;\n  let secondsSinceStateTransitionOutput;\n  let stageProgressOutput = 0;\n  let valueOnReleaseOutput = undefined;\n  let valueOutput = undefined;\n  if (stage === 'rest') {\n    if (triggerValue <= 0) {\n      stageOutput = 'rest';\n      secondsSinceStateTransitionOutput = secondsSinceStateTransition + sampleTime;\n      valueOutput = 0;\n    } else {\n      if (sampleTime < attackTime) {\n        stageOutput = 'attack';\n        secondsSinceStateTransitionOutput = sampleTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / attackTime;\n        valueOutput = getValueAtTime(\n          0,\n          0,\n          attackValue,\n          attackTime,\n          secondsSinceStateTransitionOutput\n        );\n      } else if (sampleTime - attackTime < holdTime) {\n        stageOutput = 'hold';\n        secondsSinceStateTransitionOutput = sampleTime - attackTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / holdTime;\n        valueOutput = attackValue;\n      } else if (sampleTime - attackTime - holdTime < decayTime) {\n        stageOutput = 'decay';\n        secondsSinceStateTransitionOutput = sampleTime - attackTime - holdTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / decayTime;\n        valueOutput = getValueAtTime(\n          attackValue,\n          0,\n          sustainValue,\n          decayTime,\n          secondsSinceStateTransitionOutput\n        );\n      } else {\n        stageOutput = 'sustain';\n        secondsSinceStateTransitionOutput = sampleTime - attackTime - holdTime - decayTime;\n        valueOutput = sustainValue;\n      }\n    }\n  }\n  if (stage === 'attack') {\n    if (triggerValue <= 0) {\n      if (sampleTime < releaseTime) {\n        stageOutput = 'release';\n        secondsSinceStateTransitionOutput = sampleTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / releaseTime;\n        if (secondsSinceStateTransition < attackTime) {\n          valueOnReleaseOutput = getValueAtTime(\n            0,\n            0,\n            attackValue,\n            attackTime,\n            secondsSinceStateTransition\n          );\n        } else if (secondsSinceStateTransition - attackTime < holdTime) {\n          valueOnReleaseOutput = attackValue;\n        } else if (secondsSinceStateTransition - attackTime - holdTime < decayTime) {\n          valueOnReleaseOutput = getValueAtTime(\n            attackValue,\n            0,\n            sustainValue,\n            decayTime,\n            secondsSinceStateTransition - attackTime - holdTime\n          );\n        } else {\n          valueOnReleaseOutput = sustainValue;\n        }\n        valueOutput = getValueAtTime(\n          valueOnReleaseOutput,\n          0,\n          0,\n          releaseTime,\n          secondsSinceStateTransitionOutput\n        );\n      } else {\n        stageOutput = 'rest';\n        secondsSinceStateTransitionOutput = sampleTime - releaseTime;\n        valueOutput = 0;\n      }\n    } else {\n      if (secondsSinceStateTransition + sampleTime < attackTime) {\n        stageOutput = 'attack';\n        secondsSinceStateTransitionOutput = secondsSinceStateTransition + sampleTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / attackTime;\n        valueOutput = getValueAtTime(\n          0,\n          0,\n          attackValue,\n          attackTime,\n          secondsSinceStateTransitionOutput\n        );\n      } else if (secondsSinceStateTransition + sampleTime - attackTime < holdTime) {\n        stageOutput = 'hold';\n        secondsSinceStateTransitionOutput = secondsSinceStateTransition + sampleTime - attackTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / holdTime;\n        valueOutput = attackValue;\n      } else if (secondsSinceStateTransition + sampleTime - attackTime - holdTime < decayTime) {\n        stageOutput = 'decay';\n        secondsSinceStateTransitionOutput =\n          secondsSinceStateTransition + sampleTime - attackTime - holdTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / decayTime;\n        valueOutput = getValueAtTime(\n          attackValue,\n          0,\n          sustainValue,\n          decayTime,\n          secondsSinceStateTransitionOutput\n        );\n      } else {\n        stageOutput = 'sustain';\n        secondsSinceStateTransitionOutput =\n          secondsSinceStateTransition + sampleTime - attackTime - holdTime - decayTime;\n        valueOutput = sustainValue;\n      }\n    }\n  }\n  if (stage === 'hold') {\n    if (triggerValue <= 0) {\n      if (sampleTime < releaseTime) {\n        stageOutput = 'release';\n        secondsSinceStateTransitionOutput = sampleTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / releaseTime;\n        if (secondsSinceStateTransition < holdTime) {\n          valueOnReleaseOutput = attackValue;\n        } else if (secondsSinceStateTransition - holdTime < decayTime) {\n          valueOnReleaseOutput = getValueAtTime(\n            attackValue,\n            0,\n            sustainValue,\n            decayTime,\n            secondsSinceStateTransition - holdTime\n          );\n        } else {\n          valueOnReleaseOutput = sustainValue;\n        }\n        valueOutput = getValueAtTime(\n          valueOnReleaseOutput,\n          0,\n          0,\n          releaseTime,\n          secondsSinceStateTransitionOutput\n        );\n      } else {\n        stageOutput = 'rest';\n        secondsSinceStateTransitionOutput = sampleTime - releaseTime;\n        valueOutput = 0;\n      }\n    } else {\n      if (secondsSinceStateTransition + sampleTime < holdTime) {\n        stageOutput = 'hold';\n        secondsSinceStateTransitionOutput = secondsSinceStateTransition + sampleTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / holdTime;\n        valueOutput = attackValue;\n      } else if (secondsSinceStateTransition + sampleTime - holdTime < decayTime) {\n        stageOutput = 'decay';\n        secondsSinceStateTransitionOutput = secondsSinceStateTransition + sampleTime - holdTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / decayTime;\n        valueOutput = getValueAtTime(\n          attackValue,\n          0,\n          sustainValue,\n          decayTime,\n          secondsSinceStateTransitionOutput\n        );\n      } else {\n        stageOutput = 'sustain';\n        secondsSinceStateTransitionOutput =\n          secondsSinceStateTransition + sampleTime - holdTime - decayTime;\n        valueOutput = sustainValue;\n      }\n    }\n  }\n  if (stage === 'decay') {\n    if (triggerValue <= 0) {\n      if (sampleTime < releaseTime) {\n        stageOutput = 'release';\n        secondsSinceStateTransitionOutput = sampleTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / releaseTime;\n        if (secondsSinceStateTransition < decayTime) {\n          valueOnReleaseOutput = getValueAtTime(\n            attackValue,\n            0,\n            sustainValue,\n            decayTime,\n            secondsSinceStateTransition\n          );\n        } else {\n          valueOnReleaseOutput = sustainValue;\n        }\n        valueOutput = getValueAtTime(\n          valueOnReleaseOutput,\n          0,\n          0,\n          releaseTime,\n          secondsSinceStateTransitionOutput\n        );\n      } else {\n        stageOutput = 'rest';\n        secondsSinceStateTransitionOutput = sampleTime - releaseTime;\n        valueOutput = 0;\n      }\n    } else {\n      if (secondsSinceStateTransition + sampleTime < decayTime) {\n        stageOutput = 'decay';\n        secondsSinceStateTransitionOutput = secondsSinceStateTransition + sampleTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / decayTime;\n        valueOutput = getValueAtTime(\n          attackValue,\n          0,\n          sustainValue,\n          decayTime,\n          secondsSinceStateTransitionOutput\n        );\n      } else {\n        stageOutput = 'sustain';\n        secondsSinceStateTransitionOutput = secondsSinceStateTransition + sampleTime - decayTime;\n        valueOutput = sustainValue;\n      }\n    }\n  }\n  if (stage === 'sustain') {\n    if (triggerValue <= 0) {\n      if (sampleTime < releaseTime) {\n        stageOutput = 'release';\n        secondsSinceStateTransitionOutput = sampleTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / releaseTime;\n        valueOnReleaseOutput = sustainValue;\n        valueOutput = getValueAtTime(\n          valueOnReleaseOutput,\n          0,\n          0,\n          releaseTime,\n          secondsSinceStateTransitionOutput\n        );\n      } else {\n        stageOutput = 'rest';\n        secondsSinceStateTransitionOutput = sampleTime - releaseTime;\n        valueOutput = 0;\n      }\n    } else {\n      stageOutput = 'sustain';\n      secondsSinceStateTransitionOutput = secondsSinceStateTransition + sampleTime;\n      valueOutput = sustainValue;\n    }\n  }\n  if (stage === 'release') {\n    if (triggerValue <= 0) {\n      if (secondsSinceStateTransition + sampleTime < releaseTime) {\n        stageOutput = 'release';\n        secondsSinceStateTransitionOutput = secondsSinceStateTransition + sampleTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / releaseTime;\n        valueOnReleaseOutput = valueOnRelease;\n        valueOutput = getValueAtTime(\n          valueOnReleaseOutput,\n          0,\n          0,\n          releaseTime,\n          secondsSinceStateTransition\n        );\n      } else {\n        stageOutput = 'rest';\n        secondsSinceStateTransitionOutput = secondsSinceStateTransition + sampleTime - releaseTime;\n        valueOutput = 0;\n      }\n    } else {\n      if (sampleTime < attackTime) {\n        stageOutput = 'attack';\n        secondsSinceStateTransitionOutput = sampleTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / attackTime;\n        valueOutput = getValueAtTime(\n          0,\n          0,\n          attackValue,\n          attackTime,\n          secondsSinceStateTransitionOutput\n        );\n      } else if (sampleTime - attackTime < holdTime) {\n        stageOutput = 'hold';\n        secondsSinceStateTransitionOutput = sampleTime - attackTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / holdTime;\n        valueOutput = attackValue;\n      } else if (sampleTime - attackTime - holdTime < decayTime) {\n        stageOutput = 'decay';\n        secondsSinceStateTransitionOutput = sampleTime - attackTime - holdTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / decayTime;\n        valueOutput = getValueAtTime(\n          attackValue,\n          0,\n          sustainValue,\n          decayTime,\n          secondsSinceStateTransitionOutput\n        );\n      } else {\n        stageOutput = 'sustain';\n        secondsSinceStateTransitionOutput = sampleTime - attackTime - holdTime - decayTime;\n        valueOutput = sustainValue;\n      }\n    }\n  }\n  return {\n    stage: stageOutput,\n    stageProgress: stageProgressOutput,\n    secondsSinceStateTransition: secondsSinceStateTransitionOutput,\n    valueOnRelease: valueOnReleaseOutput,\n    outputValue: valueOutput\n  };\n};\n","import { getParameterValue } from './getParameterValue';\nimport { getEnvelopeValue } from './getEnvelopeValue';\n\nregisterProcessor(\n  'envelope-generator',\n  class EnvelopeGenerator extends AudioWorkletProcessor {\n    static get parameterDescriptors() {\n      return [\n        {\n          name: 'attackValue',\n          defaultValue: 1,\n          minValue: 0,\n          maxValue: 1,\n          automationRate: 'a-rate'\n        },\n        {\n          name: 'attackTime',\n          defaultValue: 0,\n          minValue: 0,\n          maxValue: 10,\n          automationRate: 'a-rate'\n        },\n        {\n          name: 'holdTime',\n          minValue: 0,\n          defaultValue: 0.0625,\n          maxValue: 10,\n          automationRate: 'a-rate'\n        },\n        {\n          name: 'decayTime',\n          defaultValue: 0.125,\n          minValue: 0,\n          maxValue: 10,\n          automationRate: 'a-rate'\n        },\n        {\n          name: 'sustainValue',\n          defaultValue: 0.25,\n          minValue: 0,\n          maxValue: 1,\n          automationRate: 'a-rate'\n        },\n        {\n          name: 'releaseTime',\n          defaultValue: 0.25,\n          minValue: 0,\n          maxValue: 10\n        }\n      ];\n    }\n\n    constructor(options) {\n      super(options);\n      this.stages = ['rest', 'attack', 'hold', 'decay', 'sustain', 'release'];\n      this.stage = this.stages[0];\n      // stageProgress advances from 0 to 1 to show progress of stage\n      this.stageProgress = 0;\n      this.secondsSinceStateTransition = 0;\n      this.port.onmessage = this.handleMessage.bind(this);\n      this.state = {\n        attackTime: 0,\n        attackValue: 1,\n        holdTime: 0.0625,\n        decayTime: 0.125,\n        sustainValue: 0.25,\n        releaseTime: 0.25\n      };\n      this.sampleRate = options.sampleRate || 44100;\n      this.outputValue;\n      this.valueOnRelease = undefined;\n    }\n\n    handleMessage(event) {\n      if (event.data && event.data.type === 'getState') {\n        this.port.postMessage({\n          type: 'state',\n          state: {\n            stage: this.stage,\n            stageProgress: this.stageProgress,\n            outputValue: this.outputValue\n          }\n        });\n      }\n    }\n\n    process(inputs, outputs, parameters) {\n      // Only one input and output.\n      let input = inputs[0];\n      let output = outputs[0];\n      const getAttackTime = getParameterValue(parameters.attackTime, 0, 10);\n      const getAttackValue = getParameterValue(parameters.attackValue, 0, 1);\n      const getHoldTime = getParameterValue(parameters.holdTime, 0, 10);\n      const getDecayTime = getParameterValue(parameters.decayTime, 0, 10);\n      const getSustainValue = getParameterValue(parameters.sustainValue, 0, 1);\n      const getReleaseTime = getParameterValue(parameters.releaseTime, 0, 10);\n\n      for (let sampleIndex = 0; sampleIndex < input[0].length; sampleIndex++) {\n        this.state = {\n          attackTime: getAttackTime(sampleIndex),\n          attackValue: getAttackValue(sampleIndex),\n          holdTime: getHoldTime(sampleIndex),\n          decayTime: getDecayTime(sampleIndex),\n          sustainValue: getSustainValue(sampleIndex),\n          releaseTime: getReleaseTime(sampleIndex)\n        };\n        // only expecting one channel, but tolerating more in case\n        const inputSample = input[0][0];\n        const envelopeValue = getEnvelopeValue(\n          this.sampleRate,\n          this.state,\n          this.secondsSinceStateTransition,\n          this.stage,\n          inputSample,\n          this.valueOnRelease\n        );\n        this.stage = envelopeValue.stage;\n        this.stageProgress = envelopeValue.stageProgress;\n        this.secondsSinceStateTransition = envelopeValue.secondsSinceStateTransition;\n        this.outputValue = envelopeValue.outputValue;\n        this.valueOnRelease = envelopeValue.valueOnRelease;\n\n        for (\n          let channelIndex = 0;\n          channelIndex < input.length;\n          channelIndex++\n        ) {\n          const outputChannel = output[channelIndex];\n\n          outputChannel[sampleIndex] = this.outputValue;\n        }\n      }\n      return true;\n    }\n  }\n);\n","// based on https://webaudio.github.io/web-audio-api/#the-bitcrusher-node\nexport function crush(sample, bitDepth, fractionalDepthMode) {\n  if (bitDepth > 32) bitDepth = 32;\n  if (bitDepth < 1) bitDepth = 1;\n  if (fractionalDepthMode === 'trve') {\n    bitDepth = Math.floor(bitDepth);\n  }\n  let numberOfSteps = 2 ** bitDepth;\n  if (fractionalDepthMode === 'quantize-evenly') {\n    numberOfSteps = Math.floor(numberOfSteps);\n  }\n  const stepSize = 2 / numberOfSteps;\n  const max = 1 - stepSize;\n  if (sample >= max) return max;\n  if (sample <= -1) return -1;\n\n  return -1 + Math.floor((1 + sample) / stepSize) * stepSize;\n}\n","import { crush } from './crush-bit-fixed-point';\n\nregisterProcessor(\n  'bit-crusher-fixed-point',\n  class Noise extends AudioWorkletProcessor {\n    static get parameterDescriptors() {\n      return [\n        {\n          name: 'bitDepth',\n          defaultValue: 8,\n          minValue: 1,\n          maxValue: 32,\n          automationRate: 'a-rate'\n        }\n      ];\n    }\n\n    constructor() {\n      super();\n      this.fractionalBitDepthMode = 'quantize-evenly';\n      this.port.onmessage = this.handleMessage.bind(this);\n    }\n\n    handleMessage(event) {\n      if (\n        event.data &&\n        event.data.type === 'change-fractional-bit-depth-mode'\n      ) {\n        this.fractionalBitDepthMode = event.data.newMode;\n      }\n    }\n\n    process(inputs, outputs, parameters) {\n      // Only one input and output.\n      let input = inputs[0];\n      let output = outputs[0];\n      let bitDepth = parameters.bitDepth;\n      let bitDepthLength = bitDepth.length;\n      let getBitDepth =\n        bitDepthLength > 1 ? i => bitDepth[i] : () => bitDepth[0];\n\n      for (let channelIndex = 0; channelIndex < input.length; channelIndex++) {\n        const inputChannel = input[channelIndex];\n        const outputChannel = output[channelIndex];\n        for (\n          let sampleIndex = 0;\n          sampleIndex < inputChannel.length;\n          sampleIndex++\n        ) {\n          const inputSample = inputChannel[sampleIndex];\n          outputChannel[sampleIndex] = crush(\n            inputSample,\n            getBitDepth(sampleIndex),\n            this.fractionalBitDepthMode\n          );\n        }\n      }\n      return true;\n    }\n  }\n);\n"],"sourceRoot":""}