{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/audio-worklet-processors/getParameterValue.js","webpack:///./src/audio-worklet-processors/noise.js","webpack:///./src/audio-worklet-processors/inverse-gain.js","webpack:///./src/audio-worklet-processors/getEnvelopeValue.js","webpack:///./src/audio-worklet-processors/linear-change.js","webpack:///./src/audio-worklet-processors/envelope-generator.js","webpack:///./src/audio-worklet-processors/crush-bit-fixed-point.js","webpack:///./src/audio-worklet-processors/bit-crusher-fixed-point.js","webpack:///./src/audio-worklet-processors/divide-clock-ticks.js","webpack:///./src/audio-worklet-processors/clock-divider.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","getParameterValue","parameter","minValue","maxValue","sampleNumber","clampValue","input","clamp","length","getParamValue","getNextValue","previousValue","stepMin","stepMax","stepSize","Math","random","registerProcessor","AudioWorkletProcessor","parameterDescriptors","defaultValue","automationRate","[object Object]","super","this","samplesHeld","isTriggerValueHigh","port","onmessage","handleMessage","manualTriggerOn","triggerChangeMessage","type","event","data","inputs","outputs","parameters","output","getStepMin","getStepMax","getSampleHold","sampleHold","getNextValueTrigger","nextValueTrigger","triggerValue","postMessage","channel","getDivisor","divisor","getZeroDivisorOutput","zeroDivisorFallback","channelIndex","inputChannel","outputChannel","sampleIndex","inputSample","getEnvelopeValue","getValueAtTime","sampleRate","attackTime","attackValue","holdTime","decayTime","sustainValue","releaseTime","secondsSinceStateTransition","stage","valueOnTriggerChange","sampleTime","stageOutput","secondsSinceStateTransitionOutput","stageProgressOutput","valueOnTriggerChangeOutput","undefined","valueOutput","stageProgress","outputValue","startValue","startTime","endValue","endTime","currentTime","options","stages","state","previousTriggerValue","stateMessage","getTriggerValue","trigger","getAttackTime","getAttackValue","getHoldTime","getDecayTime","getSustainValue","getReleaseTime","envelopeValue","crush","sample","bitDepth","fractionalDepthMode","floor","numberOfSteps","max","fractionalBitDepthMode","newMode","getBitDepth","clockInTriggerStages","attack","high","release","low","clockStages","tick","tock","resetTriggerStages","reset","keepGoing","divideClockTicks","attackAfterTicks","releaseAfterTocks","clockInStage","resetTriggerStage","tocksPast","ticksPast","userParams","initialReset","manualClockTriggerOn","manualResetTriggerOn","clockTriggerOn","resetTriggerOn","clockTriggerChangeMessage","resetTriggerChangeMessage","getClockTriggerValue","clockTrigger","getResetTriggerValue","resetTrigger","getAttackAfterTicks","getReleaseAfterTocks","clockTriggerValue","resetTriggerValue","clockTriggerStage"],"mappings":"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","file":"worklets.ec481af083e082d5bbb3.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"./assets/audio-worklet-processors\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","const clamp = (minValue, maxValue) => input =>\n  input < minValue ? minValue : input > maxValue ? maxValue : input;\n\nexport const getParameterValue = (parameter, minValue, maxValue) => sampleNumber => {\n  const clampValue = clamp(minValue, maxValue);\n  if (parameter.length > 1) {\n    return clampValue(parameter[sampleNumber]);\n  }\n  return clampValue(parameter[0]);\n};\n","import { getParameterValue } from './getParameterValue';\n\nconst getParamValue = getParameterValue;\n\nconst getNextValue = (previousValue, stepMin, stepMax) => {\n  const stepSize = Math.random() * (stepMax - stepMin) + stepMin;\n  const preferUp = Math.random() > 0.5;\n  if (preferUp) {\n    return previousValue + stepSize > 1 ? previousValue - stepSize : previousValue + stepSize;\n  } else {\n    return previousValue - stepSize < -1 ? previousValue + stepSize : previousValue - stepSize;\n  }\n};\n\nregisterProcessor(\n  'noise',\n  class Noise extends AudioWorkletProcessor {\n    static get parameterDescriptors() {\n      return [\n        {\n          name: 'stepMax',\n          defaultValue: 1,\n          minValue: 0,\n          maxValue: 1,\n          automationRate: 'a-rate'\n        },\n        {\n          name: 'stepMin',\n          defaultValue: 0,\n          minValue: 0,\n          maxValue: 1,\n          automationRate: 'a-rate'\n        },\n        {\n          name: 'sampleHold',\n          defaultValue: 1,\n          minValue: 0,\n          maxValue: 1000000,\n          automationRate: 'a-rate'\n        },\n        {\n          name: 'nextValueTrigger',\n          defaultValue: 0,\n          automationRate: 'a-rate'\n        }\n      ];\n    }\n\n    constructor() {\n      super();\n      // initializing to zero means max and min of 1 behaves differently on initial load\n      // start unbalanced so there is only one option for next sample in that case\n      this.previousValue = 0.1;\n      this.samplesHeld = 0;\n      this.isTriggerValueHigh = false;\n      this.port.onmessage = this.handleMessage.bind(this);\n      this.manualTriggerOn = false;\n      this.triggerChangeMessage = { type: 'trigger-change', value: false };\n    }\n\n    handleMessage(event) {\n      if (event.data && event.data.type === 'manual-trigger') {\n        this.manualTriggerOn = event.data.value;\n      }\n    }\n\n    process(inputs, outputs, parameters) {\n      // Get the first output.\n      let output = outputs[0];\n      this.getStepMin = getParamValue(parameters.stepMin, 0, 1);\n      this.getStepMax = getParamValue(parameters.stepMax, 0, 1);\n      this.getSampleHold = getParamValue(parameters.sampleHold, 0, 1000000);\n\n      this.getNextValueTrigger = this.manualTriggerOn\n        ? () => 1e9\n        : getParamValue(parameters.nextValueTrigger, 0, 1);\n\n      for (let i = 0; i < output[0].length; ++i, ++this.samplesHeld) {\n        // recover from overflow\n        if (this.samplesHeld < 0) {\n          this.samplesHeld = 0;\n        }\n\n        const sampleHold = this.getSampleHold(i);\n\n        // keep playing previous sample forever if sampleHold < 1\n        if (sampleHold >= 1 && this.samplesHeld >= sampleHold) {\n          this.samplesHeld -= sampleHold;\n          this.previousValue = getNextValue(\n            this.previousValue,\n            this.getStepMin(i),\n            this.getStepMax(i)\n          );\n        }\n        const triggerValue = this.getNextValueTrigger(i);\n        if (this.isTriggerValueHigh != triggerValue > 0) {\n          this.triggerChangeMessage.value = triggerValue > 0;\n          this.port.postMessage(this.triggerChangeMessage);\n        }\n        if (!this.isTriggerValueHigh && triggerValue > 0) {\n          this.previousValue = getNextValue(\n            this.previousValue,\n            this.getStepMin(i),\n            this.getStepMax(i)\n          );\n        }\n        this.isTriggerValueHigh = triggerValue > 0;\n        for (let channel = 0; channel < output.length; ++channel) {\n          output[channel][i] = this.previousValue;\n        }\n      }\n      return true;\n    }\n  }\n);\n","import { getParameterValue } from \"./getParameterValue\";\n\nconst getParamValue = getParameterValue;\n\nregisterProcessor(\n  'inverse-gain',\n  class Noise extends AudioWorkletProcessor {\n    static get parameterDescriptors() {\n      return [\n        {\n          name: 'divisor',\n          defaultValue: 10,\n          automationRate: 'a-rate'\n        },\n        {\n          name: 'zeroDivisorFallback',\n          defaultValue: 0,\n          automationRate: 'a-rate'\n        }\n      ];\n    }\n\n    process(inputs, outputs, parameters) {\n      // Only one input and output.\n      let input = inputs[0];\n      let output = outputs[0];\n      this.getDivisor = getParamValue(parameters.divisor, -1e9, 1e9);\n      this.getZeroDivisorOutput = getParamValue(parameters.zeroDivisorFallback, -1e9, 1e9);\n\n      for (let channelIndex = 0; channelIndex < input.length; channelIndex++) {\n        const inputChannel = input[channelIndex];\n        const outputChannel = output[channelIndex];\n        for (\n          let sampleIndex = 0;\n          sampleIndex < inputChannel.length;\n          sampleIndex++\n        ) {\n          const inputSample = inputChannel[sampleIndex];\n          const divisor = this.getDivisor(sampleIndex);\n          if (divisor === 0) {\n            outputChannel[sampleIndex] = this.getZeroDivisorOutput(sampleIndex);\n          } else {\n            outputChannel[sampleIndex] = inputSample / divisor;\n          }\n        }\n      }\n      return true;\n    }\n  }\n);\n","// ASSUMPTION: this will be called every sample, so it's safe to always advance time by one sample\n// returns the value at end of the sample, so if attack time is 0, attack value will be returned on the sample of the recieved trigger\nexport const getEnvelopeValue = (\n  getValueAtTime,\n  sampleRate,\n  { attackTime, attackValue, holdTime, decayTime, sustainValue, releaseTime },\n  secondsSinceStateTransition,\n  stage,\n  triggerValue,\n  valueOnTriggerChange\n) => {\n  const sampleTime = 1 / sampleRate;\n  let stageOutput;\n  let secondsSinceStateTransitionOutput;\n  let stageProgressOutput = 0;\n  let valueOnTriggerChangeOutput = undefined;\n  let valueOutput = undefined;\n  if (stage === 'rest') {\n    if (triggerValue <= 0) {\n      stageOutput = 'rest';\n      secondsSinceStateTransitionOutput = secondsSinceStateTransition + sampleTime;\n      valueOutput = 0;\n    } else {\n      if (sampleTime < attackTime) {\n        stageOutput = 'attack';\n        secondsSinceStateTransitionOutput = sampleTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / attackTime;\n        valueOnTriggerChangeOutput = 0;\n        valueOutput = getValueAtTime(\n          0,\n          0,\n          attackValue,\n          attackTime,\n          secondsSinceStateTransitionOutput\n        );\n      } else if (sampleTime - attackTime < holdTime) {\n        stageOutput = 'hold';\n        secondsSinceStateTransitionOutput = sampleTime - attackTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / holdTime;\n        valueOutput = attackValue;\n      } else if (sampleTime - attackTime - holdTime < decayTime) {\n        stageOutput = 'decay';\n        secondsSinceStateTransitionOutput = sampleTime - attackTime - holdTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / decayTime;\n        valueOutput = getValueAtTime(\n          attackValue,\n          0,\n          sustainValue,\n          decayTime,\n          secondsSinceStateTransitionOutput\n        );\n      } else {\n        stageOutput = 'sustain';\n        secondsSinceStateTransitionOutput = sampleTime - attackTime - holdTime - decayTime;\n        valueOutput = sustainValue;\n      }\n    }\n  }\n  if (stage === 'attack') {\n    if (triggerValue <= 0) {\n      if (sampleTime < releaseTime) {\n        stageOutput = 'release';\n        secondsSinceStateTransitionOutput = sampleTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / releaseTime;\n        if (secondsSinceStateTransition < attackTime) {\n          valueOnTriggerChangeOutput = getValueAtTime(\n            valueOnTriggerChange || 0,\n            0,\n            attackValue,\n            attackTime,\n            secondsSinceStateTransition\n          );\n        } else if (secondsSinceStateTransition - attackTime < holdTime) {\n          valueOnTriggerChangeOutput = attackValue;\n        } else if (secondsSinceStateTransition - attackTime - holdTime < decayTime) {\n          valueOnTriggerChangeOutput = getValueAtTime(\n            attackValue,\n            0,\n            sustainValue,\n            decayTime,\n            secondsSinceStateTransition - attackTime - holdTime\n          );\n        } else {\n          valueOnTriggerChangeOutput = sustainValue;\n        }\n        valueOutput = getValueAtTime(\n          valueOnTriggerChangeOutput,\n          0,\n          0,\n          releaseTime,\n          secondsSinceStateTransitionOutput\n        );\n      } else {\n        stageOutput = 'rest';\n        secondsSinceStateTransitionOutput = sampleTime - releaseTime;\n        valueOutput = 0;\n      }\n    } else {\n      if (secondsSinceStateTransition + sampleTime < attackTime) {\n        stageOutput = 'attack';\n        secondsSinceStateTransitionOutput = secondsSinceStateTransition + sampleTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / attackTime;\n        valueOnTriggerChangeOutput = valueOnTriggerChange;\n        valueOutput = getValueAtTime(\n          valueOnTriggerChange || 0,\n          0,\n          attackValue,\n          attackTime,\n          secondsSinceStateTransitionOutput\n        );\n      } else if (secondsSinceStateTransition + sampleTime - attackTime < holdTime) {\n        stageOutput = 'hold';\n        secondsSinceStateTransitionOutput = secondsSinceStateTransition + sampleTime - attackTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / holdTime;\n        valueOutput = attackValue;\n      } else if (secondsSinceStateTransition + sampleTime - attackTime - holdTime < decayTime) {\n        stageOutput = 'decay';\n        secondsSinceStateTransitionOutput =\n          secondsSinceStateTransition + sampleTime - attackTime - holdTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / decayTime;\n        valueOutput = getValueAtTime(\n          attackValue,\n          0,\n          sustainValue,\n          decayTime,\n          secondsSinceStateTransitionOutput\n        );\n      } else {\n        stageOutput = 'sustain';\n        secondsSinceStateTransitionOutput =\n          secondsSinceStateTransition + sampleTime - attackTime - holdTime - decayTime;\n        valueOutput = sustainValue;\n      }\n    }\n  }\n  if (stage === 'hold') {\n    if (triggerValue <= 0) {\n      if (sampleTime < releaseTime) {\n        stageOutput = 'release';\n        secondsSinceStateTransitionOutput = sampleTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / releaseTime;\n        if (secondsSinceStateTransition < holdTime) {\n          valueOnTriggerChangeOutput = attackValue;\n        } else if (secondsSinceStateTransition - holdTime < decayTime) {\n          valueOnTriggerChangeOutput = getValueAtTime(\n            attackValue,\n            0,\n            sustainValue,\n            decayTime,\n            secondsSinceStateTransition - holdTime\n          );\n        } else {\n          valueOnTriggerChangeOutput = sustainValue;\n        }\n        valueOutput = getValueAtTime(\n          valueOnTriggerChangeOutput,\n          0,\n          0,\n          releaseTime,\n          secondsSinceStateTransitionOutput\n        );\n      } else {\n        stageOutput = 'rest';\n        secondsSinceStateTransitionOutput = sampleTime - releaseTime;\n        valueOutput = 0;\n      }\n    } else {\n      if (secondsSinceStateTransition + sampleTime < holdTime) {\n        stageOutput = 'hold';\n        secondsSinceStateTransitionOutput = secondsSinceStateTransition + sampleTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / holdTime;\n        valueOutput = attackValue;\n      } else if (secondsSinceStateTransition + sampleTime - holdTime < decayTime) {\n        stageOutput = 'decay';\n        secondsSinceStateTransitionOutput = secondsSinceStateTransition + sampleTime - holdTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / decayTime;\n        valueOutput = getValueAtTime(\n          attackValue,\n          0,\n          sustainValue,\n          decayTime,\n          secondsSinceStateTransitionOutput\n        );\n      } else {\n        stageOutput = 'sustain';\n        secondsSinceStateTransitionOutput =\n          secondsSinceStateTransition + sampleTime - holdTime - decayTime;\n        valueOutput = sustainValue;\n      }\n    }\n  }\n  if (stage === 'decay') {\n    if (triggerValue <= 0) {\n      if (sampleTime < releaseTime) {\n        stageOutput = 'release';\n        secondsSinceStateTransitionOutput = sampleTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / releaseTime;\n        if (secondsSinceStateTransition < decayTime) {\n          valueOnTriggerChangeOutput = getValueAtTime(\n            attackValue,\n            0,\n            sustainValue,\n            decayTime,\n            secondsSinceStateTransition\n          );\n        } else {\n          valueOnTriggerChangeOutput = sustainValue;\n        }\n        valueOutput = getValueAtTime(\n          valueOnTriggerChangeOutput,\n          0,\n          0,\n          releaseTime,\n          secondsSinceStateTransitionOutput\n        );\n      } else {\n        stageOutput = 'rest';\n        secondsSinceStateTransitionOutput = sampleTime - releaseTime;\n        valueOutput = 0;\n      }\n    } else {\n      if (secondsSinceStateTransition + sampleTime < decayTime) {\n        stageOutput = 'decay';\n        secondsSinceStateTransitionOutput = secondsSinceStateTransition + sampleTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / decayTime;\n        valueOutput = getValueAtTime(\n          attackValue,\n          0,\n          sustainValue,\n          decayTime,\n          secondsSinceStateTransitionOutput\n        );\n      } else {\n        stageOutput = 'sustain';\n        secondsSinceStateTransitionOutput = secondsSinceStateTransition + sampleTime - decayTime;\n        valueOutput = sustainValue;\n      }\n    }\n  }\n  if (stage === 'sustain') {\n    if (triggerValue <= 0) {\n      if (sampleTime < releaseTime) {\n        stageOutput = 'release';\n        secondsSinceStateTransitionOutput = sampleTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / releaseTime;\n        valueOnTriggerChangeOutput = sustainValue;\n        valueOutput = getValueAtTime(\n          valueOnTriggerChangeOutput,\n          0,\n          0,\n          releaseTime,\n          secondsSinceStateTransitionOutput\n        );\n      } else {\n        stageOutput = 'rest';\n        secondsSinceStateTransitionOutput = sampleTime - releaseTime;\n        valueOutput = 0;\n      }\n    } else {\n      stageOutput = 'sustain';\n      secondsSinceStateTransitionOutput = secondsSinceStateTransition + sampleTime;\n      valueOutput = sustainValue;\n    }\n  }\n  if (stage === 'release') {\n    if (triggerValue <= 0) {\n      if (secondsSinceStateTransition + sampleTime < releaseTime) {\n        stageOutput = 'release';\n        secondsSinceStateTransitionOutput = secondsSinceStateTransition + sampleTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / releaseTime;\n        valueOnTriggerChangeOutput = valueOnTriggerChange;\n        valueOutput = getValueAtTime(\n          valueOnTriggerChangeOutput,\n          0,\n          0,\n          releaseTime,\n          secondsSinceStateTransitionOutput\n        );\n      } else {\n        stageOutput = 'rest';\n        secondsSinceStateTransitionOutput = secondsSinceStateTransition + sampleTime - releaseTime;\n        valueOutput = 0;\n      }\n    } else {\n      if (sampleTime < attackTime) {\n        stageOutput = 'attack';\n        secondsSinceStateTransitionOutput = sampleTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / attackTime;\n        valueOnTriggerChangeOutput = getValueAtTime(valueOnTriggerChange || 0, 0, 0, releaseTime, secondsSinceStateTransition);\n        valueOutput = getValueAtTime(\n          valueOnTriggerChangeOutput,\n          0,\n          attackValue,\n          attackTime,\n          secondsSinceStateTransitionOutput\n        );\n      } else if (sampleTime - attackTime < holdTime) {\n        stageOutput = 'hold';\n        secondsSinceStateTransitionOutput = sampleTime - attackTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / holdTime;\n        valueOutput = attackValue;\n      } else if (sampleTime - attackTime - holdTime < decayTime) {\n        stageOutput = 'decay';\n        secondsSinceStateTransitionOutput = sampleTime - attackTime - holdTime;\n        stageProgressOutput = secondsSinceStateTransitionOutput / decayTime;\n        valueOutput = getValueAtTime(\n          attackValue,\n          0,\n          sustainValue,\n          decayTime,\n          secondsSinceStateTransitionOutput\n        );\n      } else {\n        stageOutput = 'sustain';\n        secondsSinceStateTransitionOutput = sampleTime - attackTime - holdTime - decayTime;\n        valueOutput = sustainValue;\n      }\n    }\n  }\n  return {\n    stage: stageOutput,\n    stageProgress: stageProgressOutput,\n    secondsSinceStateTransition: secondsSinceStateTransitionOutput,\n    valueOnTriggerChange: valueOnTriggerChangeOutput,\n    outputValue: valueOutput\n  };\n};\n","export function getValueAtTime(\n  startValue,\n  startTime,\n  endValue,\n  endTime,\n  currentTime\n) {\n  if (startTime >= endTime) {\n    startTime = endTime;\n  }\n  if (currentTime >= endTime) {\n    return endValue;\n  }\n  if (currentTime <= startTime) {\n    return startValue;\n  }\n\n  const gradient = (endValue - startValue) / (endTime - startTime);\n  return startValue + (currentTime - startTime) * gradient;\n}\n","import { getParameterValue } from './getParameterValue';\nimport { getEnvelopeValue } from './getEnvelopeValue';\nimport { getValueAtTime } from './linear-change';\n\nconst getParamValue = getParameterValue;\n\nregisterProcessor(\n  'envelope-generator',\n  class EnvelopeGenerator extends AudioWorkletProcessor {\n    static get parameterDescriptors() {\n      return [\n        {\n          name: 'trigger',\n          defaultValue: 0,\n          automationRate: 'a-rate'\n        },\n        {\n          name: 'attackValue',\n          defaultValue: 1,\n          minValue: 0,\n          maxValue: 1,\n          automationRate: 'a-rate'\n        },\n        {\n          name: 'attackTime',\n          defaultValue: 0.001,\n          minValue: 0,\n          maxValue: 10,\n          automationRate: 'a-rate'\n        },\n        {\n          name: 'holdTime',\n          minValue: 0,\n          defaultValue: 0.0625,\n          maxValue: 10,\n          automationRate: 'a-rate'\n        },\n        {\n          name: 'decayTime',\n          defaultValue: 0.125,\n          minValue: 0,\n          maxValue: 10,\n          automationRate: 'a-rate'\n        },\n        {\n          name: 'sustainValue',\n          defaultValue: 0.25,\n          minValue: 0,\n          maxValue: 1,\n          automationRate: 'a-rate'\n        },\n        {\n          name: 'releaseTime',\n          defaultValue: 0.25,\n          minValue: 0,\n          maxValue: 10\n        }\n      ];\n    }\n\n    constructor(options) {\n      super(options);\n      this.stages = ['rest', 'attack', 'hold', 'decay', 'sustain', 'release'];\n      this.stage = this.stages[0];\n      // stageProgress advances from 0 to 1 to show progress of stage\n      this.stageProgress = 0;\n      this.secondsSinceStateTransition = 0;\n      this.port.onmessage = this.handleMessage.bind(this);\n      this.state = {\n        attackTime: 0.001,\n        attackValue: 1,\n        holdTime: 0.0625,\n        decayTime: 0.125,\n        sustainValue: 0.25,\n        releaseTime: 0.25\n      };\n      this.sampleRate = options.sampleRate || 44100;\n      this.outputValue = 0;\n      this.valueOnTriggerChange = undefined;\n      this.manualTriggerOn = false;\n      this.previousTriggerValue = 0;\n      this.stateMessage = {\n        type: 'state',\n        state: {\n          stage: this.stage,\n          stageProgress: this.stageProgress,\n          outputValue: this.outputValue\n        }\n      };\n      this.triggerChangeMessage = { type: 'trigger-change', value: false };\n    }\n\n    handleMessage(event) {\n      if (event.data && event.data.type === 'getState') {\n        this.stateMessage.state.stage = this.stage;\n        this.stateMessage.state.stageProgress = this.stageProgress;\n        this.stateMessage.state.outputValue = this.outputValue;\n        this.port.postMessage(this.stateMessage);\n      }\n      if (event.data && event.data.type === 'manual-trigger') {\n        this.manualTriggerOn = event.data.value;\n      }\n    }\n\n    process(inputs, outputs, parameters) {\n      // Only one output.\n      let output = outputs[0];\n      this.getTriggerValue = this.manualTriggerOn\n        ? () => 1e9\n        : getParamValue(parameters.trigger, -1e9, 1e9);\n      this.getAttackTime = getParamValue(parameters.attackTime, 0, 10);\n      this.getAttackValue = getParamValue(parameters.attackValue, 0, 1);\n      this.getHoldTime = getParamValue(parameters.holdTime, 0, 10);\n      this.getDecayTime = getParamValue(parameters.decayTime, 0, 10);\n      this.getSustainValue = getParamValue(parameters.sustainValue, 0, 1);\n      this.getReleaseTime = getParamValue(parameters.releaseTime, 0, 10);\n\n      for (let sampleIndex = 0; sampleIndex < output[0].length; sampleIndex++) {\n        this.state.attackTime = this.getAttackTime(sampleIndex);\n        this.state.attackValue = this.getAttackValue(sampleIndex);\n        this.state.holdTime = this.getHoldTime(sampleIndex);\n        this.state.decayTime = this.getDecayTime(sampleIndex);\n        this.state.sustainValue = this.getSustainValue(sampleIndex);\n        this.state.releaseTime = this.getReleaseTime(sampleIndex);\n        const triggerValue = this.getTriggerValue(sampleIndex);\n\n        if (triggerValue > 0 != this.previousTriggerValue > 0) {\n          this.triggerChangeMessage.value = triggerValue > 0;\n          this.port.postMessage(this.triggerChangeMessage);\n        }\n\n        const envelopeValue = getEnvelopeValue(\n          getValueAtTime,\n          this.sampleRate,\n          this.state,\n          this.secondsSinceStateTransition,\n          this.stage,\n          triggerValue,\n          this.valueOnTriggerChange\n        );\n        this.stage = envelopeValue.stage;\n        this.stageProgress = envelopeValue.stageProgress;\n        this.secondsSinceStateTransition = envelopeValue.secondsSinceStateTransition;\n        this.outputValue = envelopeValue.outputValue;\n        this.valueOnTriggerChange = envelopeValue.valueOnTriggerChange;\n        this.previousTriggerValue = triggerValue;\n\n        // only expecting one channel, but tolerating more in case\n        for (let channelIndex = 0; channelIndex < output.length; channelIndex++) {\n          const outputChannel = output[channelIndex];\n\n          outputChannel[sampleIndex] = this.outputValue;\n        }\n      }\n      return true;\n    }\n  }\n);\n","// based on https://webaudio.github.io/web-audio-api/#the-bitcrusher-node\nexport function crush(sample, bitDepth, fractionalDepthMode) {\n  if (bitDepth > 32) bitDepth = 32;\n  if (bitDepth < 1) bitDepth = 1;\n  if (fractionalDepthMode === 'trve') {\n    bitDepth = Math.floor(bitDepth);\n  }\n  let numberOfSteps = 2 ** bitDepth;\n  if (fractionalDepthMode === 'quantize-evenly') {\n    numberOfSteps = Math.floor(numberOfSteps);\n  }\n  const stepSize = 2 / numberOfSteps;\n  const max = 1 - stepSize;\n  if (sample >= max) return max;\n  if (sample <= -1) return -1;\n\n  return -1 + Math.floor((1 + sample) / stepSize) * stepSize;\n}\n","import { crush } from './crush-bit-fixed-point';\nimport { getParameterValue } from './getParameterValue';\n\nconst getParamValue = getParameterValue;\n\nregisterProcessor(\n  'bit-crusher-fixed-point',\n  class Noise extends AudioWorkletProcessor {\n    static get parameterDescriptors() {\n      return [\n        {\n          name: 'bitDepth',\n          defaultValue: 8,\n          minValue: 1,\n          maxValue: 32,\n          automationRate: 'a-rate'\n        }\n      ];\n    }\n\n    constructor() {\n      super();\n      this.fractionalBitDepthMode = 'quantize-evenly';\n      this.port.onmessage = this.handleMessage.bind(this);\n    }\n\n    handleMessage(event) {\n      if (event.data && event.data.type === 'change-fractional-bit-depth-mode') {\n        this.fractionalBitDepthMode = event.data.newMode;\n      }\n    }\n\n    process(inputs, outputs, parameters) {\n      // Only one input and output.\n      let input = inputs[0];\n      let output = outputs[0];\n      this.getBitDepth = getParamValue(parameters.bitDepth, 1, 32);\n\n      for (let channelIndex = 0; channelIndex < input.length; channelIndex++) {\n        const inputChannel = input[channelIndex];\n        const outputChannel = output[channelIndex];\n        for (let sampleIndex = 0; sampleIndex < inputChannel.length; sampleIndex++) {\n          const inputSample = inputChannel[sampleIndex];\n          outputChannel[sampleIndex] = crush(\n            inputSample,\n            this.getBitDepth(sampleIndex),\n            this.fractionalBitDepthMode\n          );\n        }\n      }\n      return true;\n    }\n  }\n);\n","export const clockInTriggerStages = {\n  attack: 1,\n  high: 2,\n  release: 3,\n  low: 4\n};\n\nexport const clockStages = {\n  tick: 1,\n  tock: 0\n};\n\nexport const resetTriggerStages = {\n  reset: 1,\n  keepGoing: 0\n};\n\nexport function divideClockTicks(\n  state, // { stage, ticksPast, tocksPast },\n  { attackAfterTicks, releaseAfterTocks },\n  clockInStage,\n  resetTriggerStage\n) {\n  if (resetTriggerStage === resetTriggerStages.reset) {\n    state.stage = clockStages.tock;\n    state.tocksPast = 0;\n    state.ticksPast = attackAfterTicks - 1;\n  }\n  if (clockInStage === clockInTriggerStages.attack && state.stage === clockStages.tock) {\n    state.ticksPast++;\n    if (state.ticksPast >= attackAfterTicks) {\n      state.stage = clockStages.tick;\n      state.ticksPast -= attackAfterTicks;\n    }\n  }\n  if (clockInStage === clockInTriggerStages.release && state.stage === clockStages.tick) {\n    state.tocksPast++;\n    if (state.tocksPast >= releaseAfterTocks) {\n      state.stage = clockStages.tock;\n      state.tocksPast -= releaseAfterTocks;\n    }\n  }\n  return state;\n}\n","import {\n  clockInTriggerStages,\n  clockStages,\n  divideClockTicks,\n  resetTriggerStages\n} from './divide-clock-ticks';\nimport { getParameterValue } from './getParameterValue';\n\n// Webpack turns function imports into object constructor calls\n// local assignment prevents many object constructor calls\nconst getParamValue = getParameterValue;\n\nregisterProcessor(\n  'clock-divider',\n  class ClockDivider extends AudioWorkletProcessor {\n    static get parameterDescriptors() {\n      return [\n        {\n          name: 'clockTrigger',\n          defaultValue: 0,\n          automationRate: 'a-rate'\n        },\n        {\n          name: 'resetTrigger',\n          defaultValue: 0,\n          automationRate: 'a-rate'\n        },\n        {\n          name: 'attackAfterTicks',\n          defaultValue: 1,\n          minValue: 1,\n          maxValue: 1e9,\n          automationRate: 'a-rate'\n        },\n        {\n          name: 'releaseAfterTocks',\n          defaultValue: 1,\n          minValue: 1,\n          maxValue: 1e9,\n          automationRate: 'a-rate'\n        }\n      ];\n    }\n    constructor(options) {\n      super(options);\n      this.state = {\n        stage: clockStages.tock,\n        // will be set according to params on reset\n        ticksPast: 0,\n        tocksPast: 0\n      };\n      this.userParams = { attackAfterTicks: 0, releaseAfterTocks: 0 };\n      this.initialReset = true;\n      this.port.onmessage = this.handleMessage.bind(this);\n      this.manualClockTriggerOn = false;\n      this.manualResetTriggerOn = false;\n      this.clockTriggerOn = false;\n      this.resetTriggerOn = false;\n      this.clockTriggerChangeMessage = { type: 'clock-trigger-change', value: false };\n      this.resetTriggerChangeMessage = { type: 'reset-trigger-change', value: false };\n    }\n\n    handleMessage(event) {\n      if (event.data && event.data.type === 'manual-clock-trigger') {\n        this.manualClockTriggerOn = event.data.value;\n      }\n      if (event.data && event.data.type === 'manual-reset-trigger') {\n        this.manualResetTriggerOn = event.data.value;\n      }\n    }\n\n    process(inputs, outputs, parameters) {\n      const output = outputs[0];\n\n      this.getClockTriggerValue = this.manualClockTriggerOn\n        ? () => 1e9\n        : getParamValue(parameters.clockTrigger, -1e9, 1e9);\n      this.getResetTriggerValue =\n        this.manualResetTriggerOn || this.initialReset\n          ? () => {\n              this.initialReset = false;\n              return 1e9;\n            }\n          : getParamValue(parameters.resetTrigger, -1e9, 1e9);\n      this.getAttackAfterTicks = getParamValue(parameters.attackAfterTicks, 1, 1e9);\n      this.getReleaseAfterTocks = getParamValue(parameters.releaseAfterTocks, 1, 1e9);\n\n      for (let sampleIndex = 0; sampleIndex < output[0].length; sampleIndex++) {\n        const clockTriggerValue = this.getClockTriggerValue(sampleIndex);\n        const resetTriggerValue = this.getResetTriggerValue(sampleIndex);\n        let clockTriggerStage;\n        if (clockTriggerValue > 0) {\n          if (this.clockTriggerOn) {\n            clockTriggerStage = clockInTriggerStages.high;\n          } else {\n            clockTriggerStage = clockInTriggerStages.attack;\n            this.clockTriggerChangeMessage.value = true;\n            this.port.postMessage(this.clockTriggerChangeMessage);\n          }\n          this.clockTriggerOn = true;\n        } else {\n          if (this.clockTriggerOn) {\n            clockTriggerStage = clockInTriggerStages.release;\n            this.clockTriggerChangeMessage.value = false;\n            this.port.postMessage(this.clockTriggerChangeMessage);\n          } else {\n            clockTriggerStage = clockInTriggerStages.low;\n          }\n          this.clockTriggerOn = false;\n        }\n        let resetTriggerStage = resetTriggerStages.keepGoing;\n\n        if (this.resetTriggerOn !== resetTriggerValue > 0) {\n          this.resetTriggerChangeMessage.value = resetTriggerValue > 0;\n          this.port.postMessage(this.resetTriggerChangeMessage);\n        }\n        if (resetTriggerValue > 0 && !this.resetTriggerOn) {\n          resetTriggerStage = resetTriggerStages.reset;\n        }\n        this.resetTriggerOn = resetTriggerValue > 0;\n\n        this.userParams.attackAfterTicks = this.getAttackAfterTicks(sampleIndex);\n        this.userParams.releaseAfterTocks = this.getReleaseAfterTocks(sampleIndex);\n\n        // mutates this.state\n        divideClockTicks(this.state, this.userParams, clockTriggerStage, resetTriggerStage);\n        // only expecting one channel, but tolerating more in case\n        for (let channelIndex = 0; channelIndex < output.length; channelIndex++) {\n          const outputChannel = output[channelIndex];\n\n          outputChannel[sampleIndex] = this.state.stage;\n        }\n      }\n      return true;\n    }\n  }\n);\n"],"sourceRoot":""}