{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/audio-worklet-processors/getParameterValue.js","webpack:///./src/audio-worklet-processors/noise.js","webpack:///./src/audio-worklet-processors/inverse-gain.js","webpack:///./src/audio-worklet-processors/getEnvelopeValue.js","webpack:///./src/audio-worklet-processors/linear-change.js","webpack:///./src/audio-worklet-processors/envelope-generator.js","webpack:///./src/audio-worklet-processors/crush-bit-fixed-point.js","webpack:///./src/audio-worklet-processors/bit-crusher-fixed-point.js","webpack:///./src/audio-worklet-processors/divide-clock-ticks.js","webpack:///./src/audio-worklet-processors/clock-divider.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","getParameterValue","parameter","minValue","maxValue","sampleNumber","clampValue","input","clamp","length","getParamValue","getNextValue","previousValue","stepMin","stepMax","stepSize","Math","random","registerProcessor","AudioWorkletProcessor","parameterDescriptors","defaultValue","automationRate","[object Object]","super","this","samplesHeld","isTriggerValueHigh","port","onmessage","handleMessage","manualTriggerOn","triggerChangeMessage","type","event","data","inputs","outputs","parameters","output","getStepMin","getStepMax","getSampleHold","sampleHold","getNextValueTrigger","nextValueTrigger","triggerValue","postMessage","channel","getDivisor","divisor","getZeroDivisorOutput","zeroDivisorFallback","channelIndex","inputChannel","outputChannel","sampleIndex","inputSample","getEnvelopeValue","getValueAtTime","sampleRate","attackTime","attackValue","holdTime","decayTime","sustainValue","releaseTime","secondsSinceStateTransition","stage","valueOnTriggerChange","sampleTime","undefined","stageProgress","outputValue","startValue","startTime","endValue","endTime","currentTime","options","state","previousTriggerValue","stateMessage","outputCache","getTriggerValue","trigger","getAttackTime","getAttackValue","getHoldTime","getDecayTime","getSustainValue","getReleaseTime","crush","sample","bitDepth","fractionalDepthMode","floor","numberOfSteps","max","fractionalBitDepthMode","newMode","getBitDepth","clockInTriggerStages","attack","high","release","low","clockStages","tick","tock","resetTriggerStages","reset","keepGoing","divideClockTicks","attackAfterTicks","releaseAfterTocks","clockInStage","resetTriggerStage","tocksPast","ticksPast","userParams","initialReset","manualClockTriggerOn","manualResetTriggerOn","clockTriggerOn","resetTriggerOn","clockTriggerChangeMessage","resetTriggerChangeMessage","getClockTriggerValue","clockTrigger","getResetTriggerValue","resetTrigger","getAttackAfterTicks","getReleaseAfterTocks","clockTriggerValue","resetTriggerValue","clockTriggerStage"],"mappings":"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","file":"worklets.e529af0cfd9356958b1e.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"./assets/audio-worklet-processors\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","const clamp = (minValue, maxValue) => input =>\n  input < minValue ? minValue : input > maxValue ? maxValue : input;\n\nexport const getParameterValue = (parameter, minValue, maxValue) => sampleNumber => {\n  const clampValue = clamp(minValue, maxValue);\n  if (parameter.length > 1) {\n    return clampValue(parameter[sampleNumber]);\n  }\n  return clampValue(parameter[0]);\n};\n","import { getParameterValue } from './getParameterValue';\n\nconst getParamValue = getParameterValue;\n\nconst getNextValue = (previousValue, stepMin, stepMax) => {\n  const stepSize = Math.random() * (stepMax - stepMin) + stepMin;\n  const preferUp = Math.random() > 0.5;\n  if (preferUp) {\n    return previousValue + stepSize > 1 ? previousValue - stepSize : previousValue + stepSize;\n  } else {\n    return previousValue - stepSize < -1 ? previousValue + stepSize : previousValue - stepSize;\n  }\n};\n\nregisterProcessor(\n  'noise',\n  class Noise extends AudioWorkletProcessor {\n    static get parameterDescriptors() {\n      return [\n        {\n          name: 'stepMax',\n          defaultValue: 1,\n          minValue: 0,\n          maxValue: 1,\n          automationRate: 'a-rate'\n        },\n        {\n          name: 'stepMin',\n          defaultValue: 0,\n          minValue: 0,\n          maxValue: 1,\n          automationRate: 'a-rate'\n        },\n        {\n          name: 'sampleHold',\n          defaultValue: 1,\n          minValue: 0,\n          maxValue: 1000000,\n          automationRate: 'a-rate'\n        },\n        {\n          name: 'nextValueTrigger',\n          defaultValue: 0,\n          automationRate: 'a-rate'\n        }\n      ];\n    }\n\n    constructor() {\n      super();\n      // initializing to zero means max and min of 1 behaves differently on initial load\n      // start unbalanced so there is only one option for next sample in that case\n      this.previousValue = 0.1;\n      this.samplesHeld = 0;\n      this.isTriggerValueHigh = false;\n      this.port.onmessage = this.handleMessage.bind(this);\n      this.manualTriggerOn = false;\n      this.triggerChangeMessage = { type: 'trigger-change', value: false };\n    }\n\n    handleMessage(event) {\n      if (event.data && event.data.type === 'manual-trigger') {\n        this.manualTriggerOn = event.data.value;\n      }\n    }\n\n    process(inputs, outputs, parameters) {\n      // Get the first output.\n      let output = outputs[0];\n      this.getStepMin = getParamValue(parameters.stepMin, 0, 1);\n      this.getStepMax = getParamValue(parameters.stepMax, 0, 1);\n      this.getSampleHold = getParamValue(parameters.sampleHold, 0, 1000000);\n\n      this.getNextValueTrigger = this.manualTriggerOn\n        ? () => 1e9\n        : getParamValue(parameters.nextValueTrigger, 0, 1);\n\n      for (let i = 0; i < output[0].length; ++i, ++this.samplesHeld) {\n        // recover from overflow\n        if (this.samplesHeld < 0) {\n          this.samplesHeld = 0;\n        }\n\n        const sampleHold = this.getSampleHold(i);\n\n        // keep playing previous sample forever if sampleHold < 1\n        if (sampleHold >= 1 && this.samplesHeld >= sampleHold) {\n          this.samplesHeld -= sampleHold;\n          this.previousValue = getNextValue(\n            this.previousValue,\n            this.getStepMin(i),\n            this.getStepMax(i)\n          );\n        }\n        const triggerValue = this.getNextValueTrigger(i);\n        if (this.isTriggerValueHigh != triggerValue > 0) {\n          this.triggerChangeMessage.value = triggerValue > 0;\n          this.port.postMessage(this.triggerChangeMessage);\n        }\n        if (!this.isTriggerValueHigh && triggerValue > 0) {\n          this.previousValue = getNextValue(\n            this.previousValue,\n            this.getStepMin(i),\n            this.getStepMax(i)\n          );\n        }\n        this.isTriggerValueHigh = triggerValue > 0;\n        for (let channel = 0; channel < output.length; ++channel) {\n          output[channel][i] = this.previousValue;\n        }\n      }\n      return true;\n    }\n  }\n);\n","import { getParameterValue } from \"./getParameterValue\";\n\nconst getParamValue = getParameterValue;\n\nregisterProcessor(\n  'inverse-gain',\n  class Noise extends AudioWorkletProcessor {\n    static get parameterDescriptors() {\n      return [\n        {\n          name: 'divisor',\n          defaultValue: 10,\n          automationRate: 'a-rate'\n        },\n        {\n          name: 'zeroDivisorFallback',\n          defaultValue: 0,\n          automationRate: 'a-rate'\n        }\n      ];\n    }\n\n    process(inputs, outputs, parameters) {\n      // Only one input and output.\n      let input = inputs[0];\n      let output = outputs[0];\n      this.getDivisor = getParamValue(parameters.divisor, -1e9, 1e9);\n      this.getZeroDivisorOutput = getParamValue(parameters.zeroDivisorFallback, -1e9, 1e9);\n\n      for (let channelIndex = 0; channelIndex < input.length; channelIndex++) {\n        const inputChannel = input[channelIndex];\n        const outputChannel = output[channelIndex];\n        for (\n          let sampleIndex = 0;\n          sampleIndex < inputChannel.length;\n          sampleIndex++\n        ) {\n          const inputSample = inputChannel[sampleIndex];\n          const divisor = this.getDivisor(sampleIndex);\n          if (divisor === 0) {\n            outputChannel[sampleIndex] = this.getZeroDivisorOutput(sampleIndex);\n          } else {\n            outputChannel[sampleIndex] = inputSample / divisor;\n          }\n        }\n      }\n      return true;\n    }\n  }\n);\n","export const restStage = 0;\nexport const attackStage = 1;\nexport const holdStage = 2;\nexport const decayStage = 3;\nexport const sustainStage = 4;\nexport const releaseStage = 5;\n// ASSUMPTION: this will be called every sample, so it's safe to always advance time by one sample\n// returns the value at end of the sample, so if attack time is 0, attack value will be returned on the sample of the recieved trigger\nexport const getEnvelopeValue = (\n  getValueAtTime,\n  sampleRate,\n  { attackTime, attackValue, holdTime, decayTime, sustainValue, releaseTime },\n  secondsSinceStateTransition,\n  stage,\n  triggerValue,\n  valueOnTriggerChange,\n  output = {}\n) => {\n  const sampleTime = 1 / sampleRate;\n  output.stage = stage;\n  output.secondsSinceStateTransition = undefined;\n  output.stageProgress = 0;\n  output.valueOnTriggerChange = undefined;\n  output.outputValue = undefined;\n  if (stage === restStage) {\n    if (triggerValue <= 0) {\n      output.stage = restStage;\n      output.secondsSinceStateTransition = secondsSinceStateTransition + sampleTime;\n      output.outputValue = 0;\n    } else {\n      if (sampleTime < attackTime) {\n        output.stage = attackStage;\n        output.secondsSinceStateTransition = sampleTime;\n        output.stageProgress = output.secondsSinceStateTransition / attackTime;\n        output.valueOnTriggerChange = 0;\n        output.outputValue = getValueAtTime(\n          0,\n          0,\n          attackValue,\n          attackTime,\n          output.secondsSinceStateTransition\n        );\n      } else if (sampleTime - attackTime < holdTime) {\n        output.stage = holdStage;\n        output.secondsSinceStateTransition = sampleTime - attackTime;\n        output.stageProgress = output.secondsSinceStateTransition / holdTime;\n        output.outputValue = attackValue;\n      } else if (sampleTime - attackTime - holdTime < decayTime) {\n        output.stage = decayStage;\n        output.secondsSinceStateTransition = sampleTime - attackTime - holdTime;\n        output.stageProgress = output.secondsSinceStateTransition / decayTime;\n        output.outputValue = getValueAtTime(\n          attackValue,\n          0,\n          sustainValue,\n          decayTime,\n          output.secondsSinceStateTransition\n        );\n      } else {\n        output.stage = sustainStage;\n        output.secondsSinceStateTransition = sampleTime - attackTime - holdTime - decayTime;\n        output.outputValue = sustainValue;\n      }\n    }\n  }\n  if (stage === attackStage) {\n    if (triggerValue <= 0) {\n      if (sampleTime < releaseTime) {\n        output.stage = releaseStage;\n        output.secondsSinceStateTransition = sampleTime;\n        output.stageProgress = output.secondsSinceStateTransition / releaseTime;\n        if (secondsSinceStateTransition < attackTime) {\n          output.valueOnTriggerChange = getValueAtTime(\n            valueOnTriggerChange || 0,\n            0,\n            attackValue,\n            attackTime,\n            secondsSinceStateTransition\n          );\n        } else if (secondsSinceStateTransition - attackTime < holdTime) {\n          output.valueOnTriggerChange = attackValue;\n        } else if (secondsSinceStateTransition - attackTime - holdTime < decayTime) {\n          output.valueOnTriggerChange = getValueAtTime(\n            attackValue,\n            0,\n            sustainValue,\n            decayTime,\n            secondsSinceStateTransition - attackTime - holdTime\n          );\n        } else {\n          output.valueOnTriggerChange = sustainValue;\n        }\n        output.outputValue = getValueAtTime(\n          output.valueOnTriggerChange,\n          0,\n          0,\n          releaseTime,\n          output.secondsSinceStateTransition\n        );\n      } else {\n        output.stage = restStage;\n        output.secondsSinceStateTransition = sampleTime - releaseTime;\n        output.outputValue = 0;\n      }\n    } else {\n      if (secondsSinceStateTransition + sampleTime < attackTime) {\n        output.stage = attackStage;\n        output.secondsSinceStateTransition = secondsSinceStateTransition + sampleTime;\n        output.stageProgress = output.secondsSinceStateTransition / attackTime;\n        output.valueOnTriggerChange = valueOnTriggerChange;\n        output.outputValue = getValueAtTime(\n          valueOnTriggerChange || 0,\n          0,\n          attackValue,\n          attackTime,\n          output.secondsSinceStateTransition\n        );\n      } else if (secondsSinceStateTransition + sampleTime - attackTime < holdTime) {\n        output.stage = holdStage;\n        output.secondsSinceStateTransition = secondsSinceStateTransition + sampleTime - attackTime;\n        output.stageProgress = output.secondsSinceStateTransition / holdTime;\n        output.outputValue = attackValue;\n      } else if (secondsSinceStateTransition + sampleTime - attackTime - holdTime < decayTime) {\n        output.stage = decayStage;\n        output.secondsSinceStateTransition =\n          secondsSinceStateTransition + sampleTime - attackTime - holdTime;\n        output.stageProgress = output.secondsSinceStateTransition / decayTime;\n        output.outputValue = getValueAtTime(\n          attackValue,\n          0,\n          sustainValue,\n          decayTime,\n          output.secondsSinceStateTransition\n        );\n      } else {\n        output.stage = sustainStage;\n        output.secondsSinceStateTransition =\n          secondsSinceStateTransition + sampleTime - attackTime - holdTime - decayTime;\n        output.outputValue = sustainValue;\n      }\n    }\n  }\n  if (stage === holdStage) {\n    if (triggerValue <= 0) {\n      if (sampleTime < releaseTime) {\n        output.stage = releaseStage;\n        output.secondsSinceStateTransition = sampleTime;\n        output.stageProgress = output.secondsSinceStateTransition / releaseTime;\n        if (secondsSinceStateTransition < holdTime) {\n          output.valueOnTriggerChange = attackValue;\n        } else if (secondsSinceStateTransition - holdTime < decayTime) {\n          output.valueOnTriggerChange = getValueAtTime(\n            attackValue,\n            0,\n            sustainValue,\n            decayTime,\n            secondsSinceStateTransition - holdTime\n          );\n        } else {\n          output.valueOnTriggerChange = sustainValue;\n        }\n        output.outputValue = getValueAtTime(\n          output.valueOnTriggerChange,\n          0,\n          0,\n          releaseTime,\n          output.secondsSinceStateTransition\n        );\n      } else {\n        output.stage = restStage;\n        output.secondsSinceStateTransition = sampleTime - releaseTime;\n        output.outputValue = 0;\n      }\n    } else {\n      if (secondsSinceStateTransition + sampleTime < holdTime) {\n        output.stage = holdStage;\n        output.secondsSinceStateTransition = secondsSinceStateTransition + sampleTime;\n        output.stageProgress = output.secondsSinceStateTransition / holdTime;\n        output.outputValue = attackValue;\n      } else if (secondsSinceStateTransition + sampleTime - holdTime < decayTime) {\n        output.stage = decayStage;\n        output.secondsSinceStateTransition = secondsSinceStateTransition + sampleTime - holdTime;\n        output.stageProgress = output.secondsSinceStateTransition / decayTime;\n        output.outputValue = getValueAtTime(\n          attackValue,\n          0,\n          sustainValue,\n          decayTime,\n          output.secondsSinceStateTransition\n        );\n      } else {\n        output.stage = sustainStage;\n        output.secondsSinceStateTransition =\n          secondsSinceStateTransition + sampleTime - holdTime - decayTime;\n        output.outputValue = sustainValue;\n      }\n    }\n  }\n  if (stage === decayStage) {\n    if (triggerValue <= 0) {\n      if (sampleTime < releaseTime) {\n        output.stage = releaseStage;\n        output.secondsSinceStateTransition = sampleTime;\n        output.stageProgress = output.secondsSinceStateTransition / releaseTime;\n        if (secondsSinceStateTransition < decayTime) {\n          output.valueOnTriggerChange = getValueAtTime(\n            attackValue,\n            0,\n            sustainValue,\n            decayTime,\n            secondsSinceStateTransition\n          );\n        } else {\n          output.valueOnTriggerChange = sustainValue;\n        }\n        output.outputValue = getValueAtTime(\n          output.valueOnTriggerChange,\n          0,\n          0,\n          releaseTime,\n          output.secondsSinceStateTransition\n        );\n      } else {\n        output.stage = restStage;\n        output.secondsSinceStateTransition = sampleTime - releaseTime;\n        output.outputValue = 0;\n      }\n    } else {\n      if (secondsSinceStateTransition + sampleTime < decayTime) {\n        output.stage = decayStage;\n        output.secondsSinceStateTransition = secondsSinceStateTransition + sampleTime;\n        output.stageProgress = output.secondsSinceStateTransition / decayTime;\n        output.outputValue = getValueAtTime(\n          attackValue,\n          0,\n          sustainValue,\n          decayTime,\n          output.secondsSinceStateTransition\n        );\n      } else {\n        output.stage = sustainStage;\n        output.secondsSinceStateTransition = secondsSinceStateTransition + sampleTime - decayTime;\n        output.outputValue = sustainValue;\n      }\n    }\n  }\n  if (stage === sustainStage) {\n    if (triggerValue <= 0) {\n      if (sampleTime < releaseTime) {\n        output.stage = releaseStage;\n        output.secondsSinceStateTransition = sampleTime;\n        output.stageProgress = output.secondsSinceStateTransition / releaseTime;\n        output.valueOnTriggerChange = sustainValue;\n        output.outputValue = getValueAtTime(\n          output.valueOnTriggerChange,\n          0,\n          0,\n          releaseTime,\n          output.secondsSinceStateTransition\n        );\n      } else {\n        output.stage = restStage;\n        output.secondsSinceStateTransition = sampleTime - releaseTime;\n        output.outputValue = 0;\n      }\n    } else {\n      output.stage = sustainStage;\n      output.secondsSinceStateTransition = secondsSinceStateTransition + sampleTime;\n      output.outputValue = sustainValue;\n    }\n  }\n  if (stage === releaseStage) {\n    if (triggerValue <= 0) {\n      if (secondsSinceStateTransition + sampleTime < releaseTime) {\n        output.stage = releaseStage;\n        output.secondsSinceStateTransition = secondsSinceStateTransition + sampleTime;\n        output.stageProgress = output.secondsSinceStateTransition / releaseTime;\n        output.valueOnTriggerChange = valueOnTriggerChange;\n        output.outputValue = getValueAtTime(\n          output.valueOnTriggerChange,\n          0,\n          0,\n          releaseTime,\n          output.secondsSinceStateTransition\n        );\n      } else {\n        output.stage = restStage;\n        output.secondsSinceStateTransition = secondsSinceStateTransition + sampleTime - releaseTime;\n        output.outputValue = 0;\n      }\n    } else {\n      if (sampleTime < attackTime) {\n        output.stage = attackStage;\n        output.secondsSinceStateTransition = sampleTime;\n        output.stageProgress = output.secondsSinceStateTransition / attackTime;\n        output.valueOnTriggerChange = getValueAtTime(\n          valueOnTriggerChange || 0,\n          0,\n          0,\n          releaseTime,\n          secondsSinceStateTransition\n        );\n        output.outputValue = getValueAtTime(\n          output.valueOnTriggerChange,\n          0,\n          attackValue,\n          attackTime,\n          output.secondsSinceStateTransition\n        );\n      } else if (sampleTime - attackTime < holdTime) {\n        output.stage = holdStage;\n        output.secondsSinceStateTransition = sampleTime - attackTime;\n        output.stageProgress = output.secondsSinceStateTransition / holdTime;\n        output.outputValue = attackValue;\n      } else if (sampleTime - attackTime - holdTime < decayTime) {\n        output.stage = decayStage;\n        output.secondsSinceStateTransition = sampleTime - attackTime - holdTime;\n        output.stageProgress = output.secondsSinceStateTransition / decayTime;\n        output.outputValue = getValueAtTime(\n          attackValue,\n          0,\n          sustainValue,\n          decayTime,\n          output.secondsSinceStateTransition\n        );\n      } else {\n        output.stage = sustainStage;\n        output.secondsSinceStateTransition = sampleTime - attackTime - holdTime - decayTime;\n        output.outputValue = sustainValue;\n      }\n    }\n  }\n  return output;\n};\n","export function getValueAtTime(\n  startValue,\n  startTime,\n  endValue,\n  endTime,\n  currentTime\n) {\n  if (startTime >= endTime) {\n    startTime = endTime;\n  }\n  if (currentTime >= endTime) {\n    return endValue;\n  }\n  if (currentTime <= startTime) {\n    return startValue;\n  }\n\n  const gradient = (endValue - startValue) / (endTime - startTime);\n  return startValue + (currentTime - startTime) * gradient;\n}\n","import { getParameterValue } from './getParameterValue';\nimport { getEnvelopeValue, restStage } from './getEnvelopeValue';\nimport { getValueAtTime } from './linear-change';\n\nconst getParamValue = getParameterValue;\n\nregisterProcessor(\n  'envelope-generator',\n  class EnvelopeGenerator extends AudioWorkletProcessor {\n    static get parameterDescriptors() {\n      return [\n        {\n          name: 'trigger',\n          defaultValue: 0,\n          automationRate: 'a-rate'\n        },\n        {\n          name: 'attackValue',\n          defaultValue: 1,\n          minValue: 0,\n          maxValue: 1,\n          automationRate: 'a-rate'\n        },\n        {\n          name: 'attackTime',\n          defaultValue: 0.001,\n          minValue: 0,\n          maxValue: 10,\n          automationRate: 'a-rate'\n        },\n        {\n          name: 'holdTime',\n          minValue: 0,\n          defaultValue: 0.0625,\n          maxValue: 10,\n          automationRate: 'a-rate'\n        },\n        {\n          name: 'decayTime',\n          defaultValue: 0.125,\n          minValue: 0,\n          maxValue: 10,\n          automationRate: 'a-rate'\n        },\n        {\n          name: 'sustainValue',\n          defaultValue: 0.25,\n          minValue: 0,\n          maxValue: 1,\n          automationRate: 'a-rate'\n        },\n        {\n          name: 'releaseTime',\n          defaultValue: 0.25,\n          minValue: 0,\n          maxValue: 10\n        }\n      ];\n    }\n\n    constructor(options) {\n      super(options);\n      this.stage = restStage;\n      // stageProgress advances from 0 to 1 to show progress of stage\n      this.stageProgress = 0;\n      this.secondsSinceStateTransition = 0;\n      this.port.onmessage = this.handleMessage.bind(this);\n      this.state = {\n        attackTime: 0.001,\n        attackValue: 1,\n        holdTime: 0.0625,\n        decayTime: 0.125,\n        sustainValue: 0.25,\n        releaseTime: 0.25\n      };\n      this.sampleRate = options.sampleRate || 44100;\n      this.outputValue = 0;\n      this.valueOnTriggerChange = undefined;\n      this.manualTriggerOn = false;\n      this.previousTriggerValue = 0;\n      this.stateMessage = {\n        type: 'state',\n        state: {\n          stage: this.stage,\n          stageProgress: this.stageProgress,\n          outputValue: this.outputValue\n        }\n      };\n      this.triggerChangeMessage = { type: 'trigger-change', value: false };\n      this.outputCache = {\n        stage: undefined,\n        secondsSinceStateTransition: undefined,\n        stageProgress: 0,\n        valueOnTriggerChange: undefined,\n        outputValue: undefined\n      };\n    }\n\n    handleMessage(event) {\n      if (event.data && event.data.type === 'getState') {\n        this.stateMessage.state.stage = this.stage;\n        this.stateMessage.state.stageProgress = this.stageProgress;\n        this.stateMessage.state.outputValue = this.outputValue;\n        this.port.postMessage(this.stateMessage);\n      }\n      if (event.data && event.data.type === 'manual-trigger') {\n        this.manualTriggerOn = event.data.value;\n      }\n    }\n\n    process(inputs, outputs, parameters) {\n      // Only one output.\n      let output = outputs[0];\n      this.getTriggerValue = this.manualTriggerOn\n        ? () => 1e9\n        : getParamValue(parameters.trigger, -1e9, 1e9);\n      this.getAttackTime = getParamValue(parameters.attackTime, 0, 10);\n      this.getAttackValue = getParamValue(parameters.attackValue, 0, 1);\n      this.getHoldTime = getParamValue(parameters.holdTime, 0, 10);\n      this.getDecayTime = getParamValue(parameters.decayTime, 0, 10);\n      this.getSustainValue = getParamValue(parameters.sustainValue, 0, 1);\n      this.getReleaseTime = getParamValue(parameters.releaseTime, 0, 10);\n\n      for (let sampleIndex = 0; sampleIndex < output[0].length; sampleIndex++) {\n        this.state.attackTime = this.getAttackTime(sampleIndex);\n        this.state.attackValue = this.getAttackValue(sampleIndex);\n        this.state.holdTime = this.getHoldTime(sampleIndex);\n        this.state.decayTime = this.getDecayTime(sampleIndex);\n        this.state.sustainValue = this.getSustainValue(sampleIndex);\n        this.state.releaseTime = this.getReleaseTime(sampleIndex);\n        const triggerValue = this.getTriggerValue(sampleIndex);\n\n        if (triggerValue > 0 != this.previousTriggerValue > 0) {\n          this.triggerChangeMessage.value = triggerValue > 0;\n          this.port.postMessage(this.triggerChangeMessage);\n        }\n\n        // mutates this.outputCache\n        getEnvelopeValue(\n          getValueAtTime,\n          this.sampleRate,\n          this.state,\n          this.secondsSinceStateTransition,\n          this.stage,\n          triggerValue,\n          this.valueOnTriggerChange,\n          this.outputCache\n        );\n        this.stage = this.outputCache.stage;\n        this.stageProgress = this.outputCache.stageProgress;\n        this.secondsSinceStateTransition = this.outputCache.secondsSinceStateTransition;\n        this.outputValue = this.outputCache.outputValue;\n        this.valueOnTriggerChange = this.outputCache.valueOnTriggerChange;\n        this.previousTriggerValue = triggerValue;\n\n        // only expecting one channel, but tolerating more in case\n        for (let channelIndex = 0; channelIndex < output.length; channelIndex++) {\n          output[channelIndex][sampleIndex] = this.outputValue;\n        }\n      }\n      return true;\n    }\n  }\n);\n","// based on https://webaudio.github.io/web-audio-api/#the-bitcrusher-node\nexport function crush(sample, bitDepth, fractionalDepthMode) {\n  if (bitDepth > 32) bitDepth = 32;\n  if (bitDepth < 1) bitDepth = 1;\n  if (fractionalDepthMode === 'trve') {\n    bitDepth = Math.floor(bitDepth);\n  }\n  let numberOfSteps = 2 ** bitDepth;\n  if (fractionalDepthMode === 'quantize-evenly') {\n    numberOfSteps = Math.floor(numberOfSteps);\n  }\n  const stepSize = 2 / numberOfSteps;\n  const max = 1 - stepSize;\n  if (sample >= max) return max;\n  if (sample <= -1) return -1;\n\n  return -1 + Math.floor((1 + sample) / stepSize) * stepSize;\n}\n","import { crush } from './crush-bit-fixed-point';\nimport { getParameterValue } from './getParameterValue';\n\nconst getParamValue = getParameterValue;\n\nregisterProcessor(\n  'bit-crusher-fixed-point',\n  class Noise extends AudioWorkletProcessor {\n    static get parameterDescriptors() {\n      return [\n        {\n          name: 'bitDepth',\n          defaultValue: 8,\n          minValue: 1,\n          maxValue: 32,\n          automationRate: 'a-rate'\n        }\n      ];\n    }\n\n    constructor() {\n      super();\n      this.fractionalBitDepthMode = 'quantize-evenly';\n      this.port.onmessage = this.handleMessage.bind(this);\n    }\n\n    handleMessage(event) {\n      if (event.data && event.data.type === 'change-fractional-bit-depth-mode') {\n        this.fractionalBitDepthMode = event.data.newMode;\n      }\n    }\n\n    process(inputs, outputs, parameters) {\n      // Only one input and output.\n      let input = inputs[0];\n      let output = outputs[0];\n      this.getBitDepth = getParamValue(parameters.bitDepth, 1, 32);\n\n      for (let channelIndex = 0; channelIndex < input.length; channelIndex++) {\n        const inputChannel = input[channelIndex];\n        const outputChannel = output[channelIndex];\n        for (let sampleIndex = 0; sampleIndex < inputChannel.length; sampleIndex++) {\n          const inputSample = inputChannel[sampleIndex];\n          outputChannel[sampleIndex] = crush(\n            inputSample,\n            this.getBitDepth(sampleIndex),\n            this.fractionalBitDepthMode\n          );\n        }\n      }\n      return true;\n    }\n  }\n);\n","export const clockInTriggerStages = {\n  attack: 1,\n  high: 2,\n  release: 3,\n  low: 4\n};\n\nexport const clockStages = {\n  tick: 1,\n  tock: 0\n};\n\nexport const resetTriggerStages = {\n  reset: 1,\n  keepGoing: 0\n};\n\nexport function divideClockTicks(\n  state, // { stage, ticksPast, tocksPast },\n  { attackAfterTicks, releaseAfterTocks },\n  clockInStage,\n  resetTriggerStage\n) {\n  if (resetTriggerStage === resetTriggerStages.reset) {\n    state.stage = clockStages.tock;\n    state.tocksPast = 0;\n    state.ticksPast = attackAfterTicks - 1;\n  }\n  if (clockInStage === clockInTriggerStages.attack && state.stage === clockStages.tock) {\n    state.ticksPast++;\n    if (state.ticksPast >= attackAfterTicks) {\n      state.stage = clockStages.tick;\n      state.ticksPast -= attackAfterTicks;\n    }\n  }\n  if (clockInStage === clockInTriggerStages.release && state.stage === clockStages.tick) {\n    state.tocksPast++;\n    if (state.tocksPast >= releaseAfterTocks) {\n      state.stage = clockStages.tock;\n      state.tocksPast -= releaseAfterTocks;\n    }\n  }\n  return state;\n}\n","import {\n  clockInTriggerStages,\n  clockStages,\n  divideClockTicks,\n  resetTriggerStages\n} from './divide-clock-ticks';\nimport { getParameterValue } from './getParameterValue';\n\n// Webpack turns function imports into object constructor calls\n// local assignment prevents many object constructor calls\nconst getParamValue = getParameterValue;\n\nregisterProcessor(\n  'clock-divider',\n  class ClockDivider extends AudioWorkletProcessor {\n    static get parameterDescriptors() {\n      return [\n        {\n          name: 'clockTrigger',\n          defaultValue: 0,\n          automationRate: 'a-rate'\n        },\n        {\n          name: 'resetTrigger',\n          defaultValue: 0,\n          automationRate: 'a-rate'\n        },\n        {\n          name: 'attackAfterTicks',\n          defaultValue: 1,\n          minValue: 1,\n          maxValue: 1e9,\n          automationRate: 'a-rate'\n        },\n        {\n          name: 'releaseAfterTocks',\n          defaultValue: 1,\n          minValue: 1,\n          maxValue: 1e9,\n          automationRate: 'a-rate'\n        }\n      ];\n    }\n    constructor(options) {\n      super(options);\n      this.state = {\n        stage: clockStages.tock,\n        // will be set according to params on reset\n        ticksPast: 0,\n        tocksPast: 0\n      };\n      this.userParams = { attackAfterTicks: 0, releaseAfterTocks: 0 };\n      this.initialReset = true;\n      this.port.onmessage = this.handleMessage.bind(this);\n      this.manualClockTriggerOn = false;\n      this.manualResetTriggerOn = false;\n      this.clockTriggerOn = false;\n      this.resetTriggerOn = false;\n      this.clockTriggerChangeMessage = { type: 'clock-trigger-change', value: false };\n      this.resetTriggerChangeMessage = { type: 'reset-trigger-change', value: false };\n    }\n\n    handleMessage(event) {\n      if (event.data && event.data.type === 'manual-clock-trigger') {\n        this.manualClockTriggerOn = event.data.value;\n      }\n      if (event.data && event.data.type === 'manual-reset-trigger') {\n        this.manualResetTriggerOn = event.data.value;\n      }\n    }\n\n    process(inputs, outputs, parameters) {\n      const output = outputs[0];\n\n      this.getClockTriggerValue = this.manualClockTriggerOn\n        ? () => 1e9\n        : getParamValue(parameters.clockTrigger, -1e9, 1e9);\n      this.getResetTriggerValue =\n        this.manualResetTriggerOn || this.initialReset\n          ? () => {\n              this.initialReset = false;\n              return 1e9;\n            }\n          : getParamValue(parameters.resetTrigger, -1e9, 1e9);\n      this.getAttackAfterTicks = getParamValue(parameters.attackAfterTicks, 1, 1e9);\n      this.getReleaseAfterTocks = getParamValue(parameters.releaseAfterTocks, 1, 1e9);\n\n      for (let sampleIndex = 0; sampleIndex < output[0].length; sampleIndex++) {\n        const clockTriggerValue = this.getClockTriggerValue(sampleIndex);\n        const resetTriggerValue = this.getResetTriggerValue(sampleIndex);\n        let clockTriggerStage;\n        if (clockTriggerValue > 0) {\n          if (this.clockTriggerOn) {\n            clockTriggerStage = clockInTriggerStages.high;\n          } else {\n            clockTriggerStage = clockInTriggerStages.attack;\n            this.clockTriggerChangeMessage.value = true;\n            this.port.postMessage(this.clockTriggerChangeMessage);\n          }\n          this.clockTriggerOn = true;\n        } else {\n          if (this.clockTriggerOn) {\n            clockTriggerStage = clockInTriggerStages.release;\n            this.clockTriggerChangeMessage.value = false;\n            this.port.postMessage(this.clockTriggerChangeMessage);\n          } else {\n            clockTriggerStage = clockInTriggerStages.low;\n          }\n          this.clockTriggerOn = false;\n        }\n        let resetTriggerStage = resetTriggerStages.keepGoing;\n\n        if (this.resetTriggerOn !== resetTriggerValue > 0) {\n          this.resetTriggerChangeMessage.value = resetTriggerValue > 0;\n          this.port.postMessage(this.resetTriggerChangeMessage);\n        }\n        if (resetTriggerValue > 0 && !this.resetTriggerOn) {\n          resetTriggerStage = resetTriggerStages.reset;\n        }\n        this.resetTriggerOn = resetTriggerValue > 0;\n\n        this.userParams.attackAfterTicks = this.getAttackAfterTicks(sampleIndex);\n        this.userParams.releaseAfterTocks = this.getReleaseAfterTocks(sampleIndex);\n\n        // mutates this.state\n        divideClockTicks(this.state, this.userParams, clockTriggerStage, resetTriggerStage);\n        // only expecting one channel, but tolerating more in case\n        for (let channelIndex = 0; channelIndex < output.length; channelIndex++) {\n          const outputChannel = output[channelIndex];\n\n          outputChannel[sampleIndex] = this.state.stage;\n        }\n      }\n      return true;\n    }\n  }\n);\n"],"sourceRoot":""}